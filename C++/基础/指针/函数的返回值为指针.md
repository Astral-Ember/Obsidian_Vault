函数的返回值为指针（的值）而不是指针变量本身

1. 返回值为指针的函数是什么
2. 返回指针变量指向地址的生命周期问题
    
    函数返回回的指针返回值，需要分情况分析
    
    2. 局部变量： 不允许返回局部变量地址，因为局部变量在函数执行完毕后就会被释放
    
    如果在外部使用可能不能得到正确结果，可能还会导致程序崩溃等问题  
    即使打了印了正确的值，但也很偶然， 不可靠的，不可预知的  
    因此，不要在返回指针变量时，返回指向局部变量的指针
    
    4. 全局变量： 允许返回全局变量地址，因为全局变量生命周期从程序开始，一直持续到程序结束
    5. 静态变量： 允许返回静态变量地址，静态变量初始化后会一直占用内存空间，直到程序结束
    6. e.g.
    
    |   |
    |---|
    |int result = 0;  <br>int* add(int a, int b)  <br>{  <br>int sum = a + b;  <br>int* ptr = &sum;  <br>return ptr;  <br>}  <br>int* add2(int a, int b)  <br>{  <br>static int sum = a + b;  <br>return &sum;  <br>}  <br>int *add3(int a, int b)  <br>{  <br>result = a + b;  <br>return &result;  <br>}  <br>int main()  <br>{  <br>int* p = add(10, 20);  <br>cout \<\< p \<\< '\n';  <br>cout \<\< *p \<\< endl;  <br>//这种情况下由于sum在函数执行完后就被销毁了，所以指针p指向的地址是一个无效地址，解引用会导致未定义行为，就会出现随机值。  <br>int* q = add2(10, 30);  <br>cout \<\< q \<\< '\n';  <br>cout \<\< *q \<\< endl;  <br>//这种情况下由于sum是静态变量，函数执行完后依然存在，所以指针q指向的地址是有效地址，解引用可以得到正确的值。  <br>int* r = add3(10, 40);  <br>cout \<\< r \<\< '\n';  <br>cout \<\< *r \<\< '\n';  <br>//这种情况下由于result是全局变量，函数执行完后依然存在，所以指针r指向的地址是有效地址，解引用可以得到正确的值。  <br>}|
    
3. 总结：

顾名思义 既然指针属于变量类型 那么自然也可以作为函数的返回值
 
函数是指针返回值时，我们返回出去的地址不能是局部变量的地址，一定是全局变量或者静态变量的  
因为局部变量用完就会被释放，之后在外部使用可能会出问题，而全局和静态变量不存在这样的问题，因为它们的生命周期是和程序“同生共死的”  
[变量作用域](变量作用域.md)、[static](static变量.md)（静态变量）  
p.s.[堆内存分配](堆上分配内存.md)也可以实现同样的效果

|   |
|---|
|int* add(int a, int b)  <br>{  <br>int* sum = new int (a + b);  <br>return sum;  <br>}  <br>int main()  <br>{  <br>int a = 10;  <br>int b = 20;  <br>int* result = add(a, b);  <br>cout \<\< result \<\< '\n';  <br>cout \<\< "Sum: " \<\< *result \<\< endl;  <br>delete result;  <br>result = nullptr;  <br>}|