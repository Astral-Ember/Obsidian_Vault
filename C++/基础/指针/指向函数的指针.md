指向函数的指针

1. 函数在内存中的存储
2. 指向函数的指针

我们之前学习了变量的存储  
变量是在内存中的小房间中的  
那么函数是否存储在内存中呢？  
答案是肯定的  
不过它的存储区域有区别！
 
当程序启动时，操作系统会将程序的各个部分（包括代码段、数据段、堆和栈）加载到内存中  
在这个过程中，程序中定义的所有函数的机器码（即执行指令）会被加载到代码段中
 
代码段:  
程序内存中的一部分，专门用于存储可执行代码。它是只读的，防止在执行过程中修改代码。  
而每个函数在代码段中都有一个入口地址，这个地址指向该函数的第一条指令。  
函数名在编译时被映射为这个地址，使得我们可以通过函数名来调用函数  
指向函数的指针（函数指针）在 C++ 中是一种强大的工具  
它允许你通过指针调用函数，实现回调函数、函数数组等功能
 
声明语法：  
返回值类型 (*指针名)(参数类型列表）  
int (*function_ptr)(int, int)  
void (*function_ptr)()
 
注意事项：  
用函数指针指向函数时，函数的返回类型和参数类型必须和函数指针的结构上完全一致  
函数指针之所以需要括号把 * 和 指针名括起来，是用于区分 函数指针 和 返回指针的函数  
函数指针一般指 指向函数的指针  
[指针函数](函数的返回值为指针.md)一般指 返回类型是指针的函数（之后会专门讲）

|   |
|---|
|void test()  <br>{  <br>cout \<\< "test information" \<\< '\n';  <br>}<br><br>  <br><br>void test2(int a, int b)  <br>{  <br>cout \<\< a + b \<\< '\n';  <br>}  <br>int main()  <br>{  <br>//声明一个函数指针 指向一个结构一样的函数  <br>void(*func)() = nullptr;//test  <br>func = test;  <br>test();  <br>func();  <br>cout \<\< func \<\< '\n';  <br>cout \<\< test \<\< '\n';//两个地址是一样的  <br>void(*func2)(int, int) = nullptr;  <br>func2 = test2;  <br>func2(10, 20);  <br>(*func2)(30, 40);  <br>//(*func)()和func()有什么区别？  <br>//本质上没有任何区别，只是写法不同  <br>//func()这样写 编译器在编译时会将其转换为(*func)()  <br>//为了代码的可读性 建议使用func()这种写法  <br>}|