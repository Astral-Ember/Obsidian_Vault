结构体嵌套，大小，内存对齐

1. 结构体的嵌套使用
    1. 我们可以在一个结构体中包含结构体 甚至声明结构体
    2. 内部嵌套的结构体，我们也可以在外部使用它来声明对象
2. 结构体占用内存大小

|   |
|---|
|struct Person  <br>{  <br>string name = "lvut";  <br>int age = 20;  <br>struct Address  <br>{  <br>string city = "chengdu";  <br>string thing[2] = { "computer","phone" };  <br>string name = "sichuan";  <br>};  <br>Address addr = { "chengdu" ,{ "computer","phone" } };  <br>};  <br>int main()  <br>{  <br>Person p;  <br>cout \<\< p.addr.city \<\< '\n';  <br>cout \<\< p.name \<\< '\n';  <br>cout \<\< p.addr.name \<\< '\n';  <br>Person* p2 = new Person;  <br>cout \<\< p2-\>addr.thing[0] \<\< '\n';  <br>}|

语法：外层结构体名::内层结构体名::内层结构体名…（支持多层嵌套）

|   |
|---|
|Person::Address addr2;  <br>cout \<\< addr2.name \<\< '\n';//sichuan|

使用 sizeof 可以有效地获取结构体的大小，包括成员变量和填充字节（为了满足特定的字节对齐要求）
 
什么是字节对齐？（内存对齐）  
在计算机内存中，数据结构的起始地址需要满足特定的规则 以便于高效地访问存储的数据  
字节对齐确保数据在内存中的存储位置符合其类型的对齐需求 从而避免因对不齐访问而导致的性能损失或潜在的硬件异常
 
每种数据类型通常都有一个对齐要求，即它在内存中存储时必须位于其一个特定的字节边界上  
例如：  
int 可能要求 4 字节对齐  
double 可能要求 8 字节对齐  
char 通常要求 1 字节对齐  
为了满足对齐要求，编译器会在结构体成员之间插入填充字节  
这些填充字节不会被直接访问，但它们保证了每个成员的地址都是对齐的  
合理的字节对齐可以提高CPU访问内存的效率  
现代CPU通常会在特定的字节边界上进行读取和写入操作，对齐访问通常比非对齐访问快得多
 
对于结构体大小而言 它的字节占用大小通常是其最大成员对齐要求的倍数  
编译器可能会在成员之间插入填充字节，以满足对齐要求  
填充字节通常会放在结构体的成员之间或结构体的末尾  
规则：

1. 每个成员变量的起始地址必须是其类型大小的倍数
2. 整个结构体的大小是最大成员对齐的倍数
3. 结构体对齐时，外部结构体需要考虑内部结构体成员变量的字节最大数

|   |
|---|
|struct Student  <br>{  <br>int score;//4 0~3  <br>int age;//4 4~7  <br>bool sex;//1 8  <br>char n;//1 9  <br>};//但是因为内存对齐的原因，编译器会在后面填充3个字节，补齐到4的倍数，所以实际占用12个字节  <br>struct Student1  <br>{  <br>int score;//4 0~3  <br>double age;//8 8~15 要求8的整数倍所以是8不是4  <br>bool sex;//1 16  <br>char n;//1 17  <br>};//因为前面是4的倍数，所以后面需要填充6个字节，补齐到8的倍数，所以实际占用24个字节  <br>struct Student2  <br>{  <br>double age;//8 0~7  <br>int score;//4 8~11  <br>bool sex;//1 12  <br>char n;//1 13  <br>};//因为前面是8的倍数，所以后面只需要填充2个字节，补齐到4的倍数，所以实际占用16个字节|