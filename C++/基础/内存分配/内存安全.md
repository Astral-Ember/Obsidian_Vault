内存安全

1. 什么是内存安全
2. 了解内存销毁机制
3. 防止内存泄漏
4. 防止越界访问
5. 空指针检查
6. 避免使用野指针

内存安全（Memory Safety）指的是程序在访问和操作内存时不会因为出现程序问题而导致崩溃、报错等情况。  
想要保证内存安全，我们们主要保证以下几点即可  
了解内存销毁时机  
防止内存泄漏  
防止越界访问  
空指针检查  
避免使用野指针
 
栈内存  
在函数调用结束时，局部变量的内存在自动销毁。  
栈内存是自动管理的，一旦程序退出某个作用域（如函数或代码块）就会释放。  
该作用域内的局部变量的内存会自动释放  
因此我们只需要注意不要在作用域外使用作用域内的在栈上分配的内存。  
堆内存  
使用 new 分配的堆内存需要在不使用后通过 delete 或 delete[] 进行释放。  
因此我们只需要注意控制堆内存对象的生命周期，不用时一定要删除。
 
堆和栈的其他区别：  
内存空间大小不同  
栈的大小通常是固定的（比如几兆），是由操作系统决定的。  
因此我们不能在其中分配太大内存。  
堆的大小取决于系统可用的内存，理论上可以分配很大的内存。  
因此我们可以在其中分配大内存。  
速度不同  
栈的分配和释放速度快，因为是由系统直接管理  
堆的分配和释放速度较慢  
线程安全  
栈是线程私有的，不同线程的栈彼此独立，是线程安全的  
谁是进程共享的，多线程访问时需要保证线程安全  
如何应用  
栈：适用于小规模、短生命周期的数据  
堆：适用于动态分配的大规模数据，或生命周期跨越函数调用的数据
 
内存泄漏主要指标不再被使用的内容一直占用内存资源  
在使用堆内存时很容易造成这样的结果  
堆内存忘记释放（一直占用堆内存）  
丢失对已分配堆内存的记录（无法释放，一直占用堆内存）  
出现以上类似的情况就会造成内存泄漏  
当内存达到一定的瓶颈就会崩溃或报错，程序无法正常运行

|   |
|---|
|int* p = new int(10);  <br>//让原本指向堆内存的指针在没有释放之前指向了别的内容，导致内存泄漏  <br>p = nullptr;  <br>p = new int(11);|

我们需要限制数组或指针的访问范围  
要避免访问超出分配范围的内存  
养成好习惯  
在声明指针没有初始化时对它赋值为nullptr  
对于指向堆内存的指针，释放后，同样对它赋值为nullptr  
这样在使用指针之前判断它是否为nullptr再决定如何使用

|   |
|---|
|int* p = nullptr;  <br>p=new int(10);  <br>delete p;  <br>p = nullptr;  <br>if (p != nullptr)  <br>{<br><br>  <br><br>}|

避免指针指向已释放的内存空间  
确定指针指向的内存不能用时，一定置空