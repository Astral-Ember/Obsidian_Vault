内存存储区域

1. 不同的内存存储区域
    1. 代码段（Code Segment，或称代码存储区）：
    2. 数据段（Data Segment，或称数据存储区）：
    3. 常量段（Constant Segment，或称常量存储区）：
    4. 栈（Stack）：
    5. 堆（Heap）：
2. 不同存储区域对我们的影响
3. 感受栈

存储 函数的机器码（执行指令）等信息的区域  
通常是只读的，防止程序意外修改自己的代码  
在程序加载时就被加载到内存中  
生命周期较长，与程序同生共死  
存储 全局变量、静态变量 等信息的区域  
一般分成两个子区段  
初始化数据段：存储已初始化的全局和静态变量  
未初始化数据段（BSS Segment）：存储未初始化的全局和静态变量，通常初始化为零  
生命周期较长，与程序同生共死  
存储 字符串字面量和其他只读数据 的区域  
通常是只读的，以防止程序修改常量的值  
例如 cout \<\< "Hello, World" \<\< endl 中的 "Hello, World" 就在存储在常量区  
生命周期和程序控制  
注意：我们声明的常量变量不存储在常量段 ，而是根据在哪里声明决定存储在哪里  
存储 局部变量、函数参数、返回值 等信息的区域  
由编译器自动管理，随着函数的调用和返回而分配和释放  
生命周期与函数调用同生共死  
存储 动态分配的内存数据 等信息的区域  
由程序员手动管理，需要主动分配、主动释放  
生命周期不固定，由程序员决定生死  
由于 全局变量、静态变量、函数等内容  
在生命周期的角度上一般不会出现什么问题（不会出现被销毁了找不到的情况）  
而会因为生命周期问题给我们带来麻烦的主要是栈和堆上存储的内容  
因此在整个开发生涯中我们需要明确区分存储在栈和堆上的内容  
栈（Stack）  
由编译器自动管理，我们无需手动管理
 
堆（Heap）  
由程序员手动管理，需要主动分配、主动释放  
生命周期不固定，由程序员决定生死  
函数中的局部变量体现  
我们之前学习[指针函数](函数的返回值为指针.md)（返回值为指针的函数）充分表现了这一点

|   |
|---|
|int *add(int a, int b)  <br>{  <br>int c = a + b;  <br>int* p = &c;  <br>return p;  <br>}|
