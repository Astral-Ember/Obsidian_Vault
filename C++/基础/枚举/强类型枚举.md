强类型枚举

1. 枚举可能存在的问题
    1. 命名冲突
    2. 隐式转换成int 不够安全
    3. 不同枚举类型之间可以产生比较
    4. 默认枚举项只能是int 大材小用
2. 强类型枚举

多个枚举中存在同名枚举项，会引发命名冲突  
会和全局变量产生冲突

|   |
|---|
|enum E_test  <br>{  <br>test1,  <br>test2  <br>};  <br>int test1 = 10;|
|![Exported image](Exported%20image%2020251125135730-0.png)|

可能不小心和整数进行混合运算  
一般不希望枚举参与到计算当中  
因为枚举是希望用于处理状态类型的

|   |
|---|
|E_test test = test1;  <br>cout \<\< 1 + test1;//1|

不同类型的枚举虽然能够比较但是逻辑上是不太合理的  
因为不同枚举之间代表的是不同的含义

|   |
|---|
|enum E_test  <br>{  <br>test1,  <br>test2  <br>};  <br>enum E_test2  <br>{  <br>t1,  <br>t2  <br>};  <br>int main()  <br>{  <br>E_test e1 = test1;  <br>E_test2 e2 = t1;  <br>if (t1 == test1)  <br>{  <br>}  <br>}|

强类型枚举是用于提升枚举的安全性  
语法：

|   |
|---|
|enum class 枚举名 { 各枚举项... };|

进行枚举变量赋值时  
枚举类型 变量 = 枚举类型::枚举项

|   |
|---|
|enum class Color { RED, GREEN, BLUE };  <br>enum class Color2 { RED, GREEN, BLUE };  <br>int RED = 10;  <br>int main()  <br>{  <br>Color c = Color::RED;  <br>Color2 c2 = Color2::RED;  <br>}|

主要作用：

1. 避免命名冲突
2. 强类型枚举无法隐式转换为整型 需要使用static_cast\<int\>(枚举值) 进行显式转换
3. 可以禁止不同类型枚举之间进行比较
4. 可以指定枚举的底层类型

若多个枚举项有同名枚举项因为存在“枚举类型::枚举项”所以不会报错  
可以避免枚举 和整型混用

|   |
|---|
|enum class Color { RED, GREEN, BLUE };  <br>enum class Color2 { RED, GREEN, BLUE };  <br>int RED = 10;  <br>int main()  <br>{  <br>Color c = Color::RED;  <br>Color2 c2 = Color2::RED;  <br>cout \<\< static_cast\<int\>(c) \<\< endl;  <br>}|

默认枚举中存储的枚举项是int类型  
我们可以利用强类型枚举指定其存储类型  
但是必须是整型类型，不能是其他类型

|   |
|---|
|enum class Color :short  <br>{ RED, GREEN, BLUE };|