里氏替换原则（用父类指针装载子类对象）

1. 基本概念
2. 基本实现
3. 栈上的里氏替换
4. 堆上的里氏替换
5. 总结

里氏替换原原则是面向对象七大原则中最重要的原则  
概念：  
任何父类出现的地方，子类都可以替代  
重点：  
语法表现一父类容器装子类对象，因为子类对象包含了父类的所有内容  
作用：  
方便进行对象存储和管理
 ![Exported image](Exported%20image%2020251125140039-0.png)

|   |
|---|
|//栈上分配  <br>GameObject player = Player();  <br>GameObject monster = Monster();  <br>GameObject boss = Boss();  <br>GameObject object[3] = { Player(),Monster(),Boss() };<br><br>  <br><br>//堆上分配  <br>GameObject *player = new Player();  <br>GameObject *monster = new Monster();  <br>GameObject *boss = new Boss();  <br>GameObject *object[3] = { new Player(),new Monster(),new Boss() };|

用父类容器装载不同的子类对象  
虽然我们可以在栈上用父类容器装子类对象  
但是不建议使用栈上的里氏替换  
主要原因：  
对象切片：用父类容器装载子类对象，子类部分会被裁掉（丢失）  
无法转换：无法将父类容器转换为子类对象  
因此，绝大多数情况下，我们应该避免在栈上使用里氏替换  
当前在堆上使用里氏替换原则  
使用父类容器装载子类对象  
不会出现对象切片，并且可以进行转换  
可以通过 dynamic_cast 将父类容器转为子类对象使用  
当学了多态后，更能体会这一点（因为需要虚函数）

![Exported image](Exported%20image%2020251125140044-1.png)

\<\>是传入想要转换为的类型  
()是具体想要转换谁  
转换失败会变成空指针（nullptr）  
总结：里氏替换原则是面向对象七大原则中最重要的原则之一。  
里氏替换的要点：  
任何父类出现的地方，子类都可以替代  
对象切片等问题在栈上使用时需注意  
可以通过动态类型转换（dynamic_cast）和判空 在某些场景下将父类对象转换为子类对象以进行访问  
重要关系：  
使用父类容器装载子类对象  
不会出现对象切片，且可以进行类型转换  
在多态的上下文中更能体现里氏替换原则  
实践要点：  
堆上的实现更易于维护和扩展  
应避免在栈上过度使用里氏替换