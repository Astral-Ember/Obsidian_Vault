菱形继承

1. 什么是菱形继承
2. 如何避免菱形继承带来的重复继承问题
3. 虚继承的原理
    1. 普通继承时，子类对象里的父类成员是复制粘贴过来的，是实实在在嵌入进去的对象一层套一层，你能看到整个家谱里每一层祖宗的字段！父亲的就是我的，我照单全收
      
      
    4. 虚继承时，子类对象中不直接嵌入虚基类成员
    
    而是通过指针或借用表间接引用虚基类  
    虚基类中的成员由最终派生类管理
    
4. 虚基类的构造调用

![Exported image](Exported%20image%2020251125140052-0.png)

在普通多重继承中，如果父类 B、C 各自继承了 A，那么子类 D 将拥有两份 A  
虽然我们可以通过 B::成员、C:: 成员来访问其中内容，但会产生二义性，且会产生内存冗余  
因此我们在实际开发中往往需要避免这类问题的发生
 
虚继承是一种告诉编译器，我继承这个父类时，只要有一个父类实例就够了 的继承方式。它可以帮助我们有效的避免菱形继承中重复继承基类的问题，让 D 只保留一份 A 的实例，避免冲突和冗余。
 
关键字与用法示例：  
关键字：virtual  
使用方式：  
class A {};  
class B : virtual public A {}; // B 虚继承自 A  
class C : virtual public A {}; // C 虚继承自 A  
class D : public B, public C {}; // D 保留一个 A 的实例

|   |   |   |   |   |
|---|---|---|---|---|
|#pragma once  <br>class A  <br>{  <br>public:  <br>int x;  <br>};|#pragma once  <br>#include "A.h"  <br>class B: virtual public A  <br>{  <br>public:  <br>int y;  <br>};|#pragma once  <br>#include "A.h"  <br>class C:virtual public A  <br>{  <br>public:  <br>int z;  <br>};|#pragma once  <br>#include"B.h"  <br>#include"C.h"  <br>class D:public B,public C  <br>{  <br>public:  <br>int w;  <br>};|#include "D.h"  <br>#include "C.h"  <br>#include "B.h"  <br>#include "A.h"  <br>#include\<iostream\>  <br>using namespace std;  <br>int main()  <br>{  <br>D d;  <br>cout \<\< d.y \<\< '\n';  <br>cout\<\< d.x \<\< '\n';  <br>//此处会报错<br><br>![Exported image](Exported%20image%2020251125140054-1.png)<br><br>}|

因为D继承自B和C，而BC都继承自A，所以不知道是从B获取x还是C获取x，换成B::x或C::x即可  
当然也可以用虚继承 代码标红部分 此时可以直接使用d.x
 
说人话：  
B和C都会有一份父类成员拷贝  
D继承B、C时，他们的成员照单全收  
D在访问B中和C中的同名成员时，需要区分是B中的还是C中的成员
 
通常编译器做法是：  
2-1. 偏移表（常见）：B、C 类对象中，保存一个偏移量，表示到真确对象的地址偏移  
2-2. 指针（少数）：B、C 类对象中，保存一个指向 A 对象的指针  
访问虚基类成员时：  
先从当前对象地址  
再加上偏移量  
跳过过去访问真正的虚基类成员
 
虚继承相比较普通继承，开销略大，但这是保证对象结构的正确性的原因  
开销变大的原因是：  
访问虚基类成员时可能需要一次额外的寻址（指针跳转）  
编译器会根据继承结构的复杂性、目标平台的架构、内存优化的需求等因素，选择指针还是偏移来管理虚基类
 
说人话：  
最底层的 D 真正“拥有” A 的那个个人  
中间的 B、C 都只是“借用” A，不是自己的财产  
它们要用A，还得找D要（通过偏移）  
在进行虚继承时，虚基类的构造是由最终派生类（最底层对象）负责调用  
中间层（如B、C）即使写了虚基类的构造，也不会生效