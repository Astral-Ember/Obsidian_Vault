继承后的构造、析构函数

1. 继承中的构造函数
2. 继承中的析构函数
3. 构造函数和析构函数不能被继承

执行顺序  
在子类进行构造时（实例化时），构造函数的执行顺序是  
按照继承顺序，先执行父类构造函数  
再按照声明顺序 执行成员对象的构造函数  
最后执行子类自己的构造函数体  
先父后子内，子内结束最后子

|   |
|---|
|#pragma once  <br>#include "Father.h"  <br>#include "Other.h"  <br>class Son : public Father  <br>{  <br>public:  <br>Other other;  <br>Son()  <br>{  <br>cout \<\< "Son()" \<\< endl;  <br>}  <br>};|

//继承自Father，先执行父类构造函数，子内创建了other对象和Son的构造函数，根据规则，优先执行子内对象的构造函数，最后再去执行子类自己的构造函数  
基类构造的调用方式  
在自动执行父类构造函数时，默认调用的是父类的无参构造 函数  
如果父类没有无参构造函数，子类必须显式调用有参构造函数  
否则会报错

![Exported image](Exported%20image%2020251125140111-0.png)

执行顺序  
在子类进行析构时，析构函数的执行顺序是  
先执行子类析构  
再析构成员对象  
最后析构父类对象  
先子后子内，子内结束最后父

|   |   |
|---|---|
|![Exported image](Exported%20image%2020251125140113-1.png)|![Exported image](Exported%20image%2020251125140115-2.png)|

构造函数不会被父类同名的构造函数覆盖  
比如：父类中有一个参构造函数 但是我们在子类中是不能使用的  
如果我们想要在子类中能够直接使用父类中的构造  
我们可以通过 using 关键字，显式的引入基类的构造函数  
语法：using 父类名::父类构造函数名;  
在子类中

|   |
|---|
|using Father::Father;//相当于声明子类要用父类的构造函数|

它的作用相当于让子类中多了一个和父类一样的构造函数  
注意：仅针对构造函数而言，析构函数不存在这样的做法，因为析构函数的规则是固定的，无法通过类似的方法引入