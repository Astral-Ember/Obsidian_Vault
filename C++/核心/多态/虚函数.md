虚函数

1. 多态的概念
2. 解决的问题
3. 多态的实现
4. 如何保留父类逻辑
5. override可以省略

多态按字面意思就是“多种形态”  
让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）  
主要目的：  
同一父类的对象 执行相同方法（行为/方法） 有不同的表现  
解决的问题  
让同一个对象有唯一行为的特征  
通过里氏替换规则体现出来的

|   |   |
|---|---|
|#pragma once  <br>#include\<iostream\>  <br>using namespace std;  <br>class Father  <br>{  <br>public:  <br>void SpeakName()  <br>{  <br>cout \<\< "father's func" \<\< '\n';  <br>}  <br>};|#pragma once  <br>#include "Father.h"  <br>class Son :  <br>public Father  <br>{  <br>public:  <br>void SpeakName()  <br>{  <br>cout \<\< "son's func" \<\< '\n';  <br>}  <br>};|

|   |
|---|
|#include "Son.h"  <br>#include\<iostream\>  <br>using namespace std;  <br>int main()  <br>{  <br>Father *f = new Son();  <br>f-\>SpeakName();//调用的是父类的方法  <br>//这是一个待解决的问题  <br>//Son *s = dynamic_cast\<Son*\>(f);  <br>//if (s != NULL)  <br>//{  <br>// s-\>SpeakName();  <br>//}  <br>}|

我们目前已经学过的多态  
编译时多态—函数重载、运算符重载，一开始就写好的  
我们将学习的：  
执行运行的多态  
实现运行时多态的关键字是：  
virtual（虚函数）在父类中

![Exported image](Exported%20image%2020251125140023-0.png)

override（推翻重写）在子类中

![Exported image](Exported%20image%2020251125140025-1.png)  

v 和 o 必定是结合使用的 来实现多态  
.cpp中可以在堆上直接实现逻辑

![Exported image](Exported%20image%2020251125140027-2.png)  

同理 如果在栈上分配这种对象 存在对象切片时 就不会执行子类中重写的方法 所以我们一般不会这样使用

![Exported image](Exported%20image%2020251125140030-3.png)

但是 ==栈上分配== ==使用引用父类容器装载，是不会对象切片== ==是可以执行子类的重写方法== ==的==

![Exported image](Exported%20image%2020251125140033-4.png)

如果想要在重写函数中保留父类逻辑 只需要在子类的方法中通过 父类名::方法名 显式调用父类逻辑即可

![Exported image](Exported%20image%2020251125140036-5.png)

如果想要在外部调用，同理  
p-\>GameObject::Atk();  
但是不建议省略