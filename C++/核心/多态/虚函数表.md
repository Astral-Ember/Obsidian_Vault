虚函数表

1. 知识回顾
    
    在程序运行时，系统中会有不同的[内存存储区域](内存存储区域.md)  
    我们目前学习过的知识，涉及的存储区域有：
    
    2. 代码段（Code Segment，或称代码存储区）：存储 函数的机器码（执行指令）等信息的区域。通常是只读的，防止程序意外修改自己的代码
      
    4. 数据段（Data Segment，或称数据存储区）：存储 全局变量、静态变量 等信息的区域
      
    6. 常量段（Constant Segment，或称常量存储区）：存储 字符串常量和其他只读数据 信息的区域
2. 虚函数表的基本概念
3. 虚函数表的工作原理
4. 多继承和单继承的区别

在程序加载时就被加到内存中  
生命期较长，与程序同生共死
 
一般分成两个子区域  
初始化数据段：存储已初始化的全局和静态变量  
未初始化数据段（BSS Segment）：存储未初始化的全局和静态变量，通常初始化为零  
生命期较长，与程序同生共死
 
通常只读的，以防止程序修改常量的值  
例如 cout \<\< "Hello, World" \<\< endl 中的 "Hello, World" 就存储在常量区  
生命期随程序控制
 
虚函数表（简称：V-Table）是C++中多态实现的底层原理  
编译器会为每一个有虚函数的类创建至少一个虚函数表  
虚函数表是一组指向该类函数的指针地址  
虚函数表被类的所有对象共享（所有实例化的某类对象都共用该类的虚函数表）  
虚函数表的对象存储在数据段或常量段（更常见）的地址  
不管实例化的对象在堆、栈、静态等哪个存储区，对应类的虚函数表永远只有一份  
每个对象中隐藏了至少一个虚函数表指针（vptr）  
该指针在对象构造时自动赋值，指向对应类的虚函数表  
定义时：  
编译器为每个有虚函数的类生成一张虚函数表，存储在数据段或常量段（更常见）  
虚函数表的本质是一组指针数据信息  
指针数组中每个元素存储着虚函数的函数指针（指向该类对应该虚函数的代码实现）
 
实例化对象时：  
存在虚函数的对象内部都会至少有一个隐藏的虚函数表指针（简称：V-Ptr）  
该指针指向虚函数表  
调用虚函数时：  
运行时会通过 vptr 指向的 VTable 查表调用相应的函数  
注意：  
只有有虚函数的类才会有虚函数表  
由于存在虚函数的类对象中隐藏的指针，大小通常比不含虚函数的对象略大

![Exported image](Exported%20image%2020251125135957-0.png)  

单继承中，子类的虚函数表可以理解为是复制父类的虚函数表后再修改  
例如修改其中的指向，添加新的自己的虚函数
 
而在多重继承中，有多少个父类就会有多少张虚函数表  
声明子类对象时，对象中会有多少个虚函数表指针指向对象的虚函数表  
对于子类自己的虚函数，将会放入第一个虚函数表中（主流编辑器的实现方式）

![Exported image](Exported%20image%2020251125140002-1.png)