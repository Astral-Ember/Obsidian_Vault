变量的本质

1. ==变量的本质==
    1. 变量的本质是2进制，即0与1
    
    例如：1byte（字节）=8bit（位）为0000 0000
    
    3. 十进制转二进制用短除法
    
    二进制转十进制如图
    
    ![Exported image](Exported%20image%2020251125135648-0.png)
2. ==8====进制和====16====进制==
    1. 8进制转换：逢8进位
    2. 8进制转10进制：从右往左看 右边的第一位为0 如果该位不为0 则加上该位乘以8的n位次方
    ![Exported image](Exported%20image%2020251125135651-1.png)4. 16进制转换：逢16进制 但是：10~A 11~B
    ![Exported image](Exported%20image%2020251125135656-2.png)
    
    十进制转16进制也是短除法  
    16进制转10进制：从右往左看 右边的第一位为0 如果该位不为0 则加上该位乘以16的n位次方
    
3. ==不同进制数的声明和作用==
    1. 十进制
    
    在日常开发中没有特殊需求均使用十进制表示数值  
    十进制声明（默认数值赋值都是10进制数）：
    
    |   |
    |---|
    |int i = 55;  <br>cout \<\< i ;|
    
    4. 二进制
    
    数据的本质都是二进制，它是一切的根本  
    二进制声明（以0b/0B开头）：
    
    |   |
    |---|
    |int i2 = 0b101;  <br>cout \<\< i2 \<\< endl;|
    
    输出为5
    
    8. 八进制
    
    八进制声明（以0开头）：
    
    |   |
    |---|
    |int i8 = 0101;  <br>cout \<\< i8 \<\< endl;|
    
    输出为65
    
    12. 十六进制
    
    用来表示内存地址的位置；用来表示颜色；文件格式和网络通讯时常用16进制表示一些信息；汇编语言中常使用16进制表示操作码和地址  
    十六进制的声明（以0x开头）：
    
    |   |
    |---|
    |int i16 = 0x101;  <br>cout \<\< i16 \<\< endl;|
    
    输出为257
    
4. ==反码和补码==
    1. 原码是什么？
    
    原码是有符号整数的最简单表示方法，使用一个符号位和数值位来表示一个整数；最高位是符号位（0表示正数，1表示负数，其余位表示数值的绝对值）  
    e.g.一个short 2个字节 16位  
    5 = 0000 0000 0000 0101  
    -5 = 1000 0000 0000 0101  
    如果在计算机中正负数都用原码表示，会出现两个0的问题，因此计算机中存储整数时不会采用原码存储
    
    3. 反码、补码是什么
    
    反码：  
    反码是一种对负数进行编码的方法，它是对原码的一种改进  
    反码算是一种中间码，一般不会直接使用  
    假设原码为 A  
    正数的反码和原码相同 = A;  
    负数的反码是对它的原码非符号位取反 = ~A（符号位不变  
    补码：  
    补码是现代计算机系统中最常用的负数表示法，解决了两个零的问题  
    假设原码为 A 反码为 B  
    正数的补码和原码相同 = A  
    负数的补码是在它的反码基础上加 1 = B + 1
    
    |   |   |   |
    |---|---|---|
    |原码|反码|补码|
    |5 = 0000 0000 0000 0101|0000 0000 0000 0101|0000 0000 0000 0101|
    |-5= 1000 0000 0000 0101|1111 1111 1111 1010|1111 1111 1111 1011|
    
    程序中所有的整数都是用补码规则表示的，这些二进制数存储在内存中的
    
    7. 为什么用补码表示负数
    
    1.解决两个零的问题  
    在原码和反码表示法中，存在两个零的情况 即：+0 和 -0  
    而在补码表示法中，只有一个零 就是 0000 0000 0000 0000  
    而补码 1000 0000 0000 0000 代表的数是  
    反码：  
    1000 0000 0000 0000 - 1 = 0111 1111 1111 1111  
    原码：  
    1000 0000 0000 0000 它是一个非常特殊的数 为 -32768 为 short 的最小值  
    2.统一加减法运算  
    只需做一步加法就行（考虑进位），即使负数的加法也适用  
    加法和减法可以通过相同的加法电路来完成，无需区分正数和正数、还是负数减在数的情况下