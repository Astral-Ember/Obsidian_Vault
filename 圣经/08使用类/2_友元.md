C++控制对类对象私有部分的访问，通常，公有类方法提供唯一的访问途径，但这样的限制太严格。所以C++提供了另外一种形式的访问权限：友元。友元有三类：
- 友元函数
- 友元类
- 友元成员函数
通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限

在为类重载二元运算符时(带两个参数的运算符)常常需要友元。将Time对象加实数就属于这种情况

此时加法运算符将一个Time值与一个 double值结合在一起。这限制了该运算符的使用方式。记住，左侧的操作数是调用对象。也就是说，下面的语句:
A = B + 2.75;

将被转换为下面的成员函数调用:
A = B.operator+ (2.75);

但下面的语句又如何呢?
A = 2.75 + B;// cannot correspond to a member function

从概念上说,2.75* B应与B* 2.75相同，但第一个表达式不对应于成员函数，因为2.75不是Time类型的对象。记住，左侧的操作数应是调用对象,但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。
## 1.创建友元
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend:
`friend Time operator+(double m, const Time & t); // goes in class declaration`
该原型意味着下面两点：
- 虽然operator+()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用;
- 虽然operator+()函数不是成员函数，但它与成员函数的访问权限相同。
第二步是编写函数定义。因为它不是成员函数，所以不要使用Time :: 限定符。另外，不要在定义中使用关键字friend，定义应该如下:
```
#include <iostream>
#include "FileName.h"
using namespace std;

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::operator+(const Time& t) const
{
	Time time;
	time.minutes = minutes + t.minutes;
	time.hours = hours + t.hours + time.minutes / 60;
	time.minutes %= 60;
	return time;
}

Time operator+(const Time& t, int d) 
{
	Time t1;
	int tt = t.hours * 60 + t.minutes + d;
	t1.hours = tt / 60;
	t1.minutes = tt % 60;
	return t1;
}

Time operator+(int d, const Time& t)
{
	return t + d;
}

void Time::Show() const
{
	cout << hours << ":" << minutes << '\n';
}

int main()
{
	Time t1(2, 30);
	Time t2(1, 30);
	Time tt;
	tt = t1 + t2;
	tt.Show();
	tt = t1 + 2;
	tt.Show();
}
```
有了上述声明和定义后，下面的语句:
A = 2.75 + B;
将转换为如下语句，从而调用刚才定义的非成员友元函数:
A = operator+ (2.75, B);

总之，类的友元函数是非成员函数，其访问权限与成员函数相同。


## 2.常用的友元：重载 << 运算符

