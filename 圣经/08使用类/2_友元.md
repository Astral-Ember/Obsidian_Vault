C++控制对类对象私有部分的访问，通常，公有类方法提供唯一的访问途径，但这样的限制太严格。所以C++提供了另外一种形式的访问权限：友元。友元有三类：
- 友元函数
- 友元类
- 友元成员函数
通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限

在为类重载二元运算符时(带两个参数的运算符)常常需要友元。将Time对象加实数就属于这种情况

此时加法运算符将一个Time值与一个 double值结合在一起。这限制了该运算符的使用方式。记住，左侧的操作数是调用对象。也就是说，下面的语句:
A = B + 2.75;

将被转换为下面的成员函数调用:
A = B.operator+ (2.75);

但下面的语句又如何呢?
A = 2.75 + B;// cannot correspond to a member function

从概念上说,2.75* B应与B* 2.75相同，但第一个表达式不对应于成员函数，因为2.75不是Time类型的对象。记住，左侧的操作数应是调用对象,但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。
## 1.创建友元
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend:
`friend Time operator+(double m, const Time & t); // goes in class declaration`
该原型意味着下面两点：
- 虽然operator+()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用;
- 虽然operator+()函数不是成员函数，但它与成员函数的访问权限相同。
第二步是编写函数定义。因为它不是成员函数，所以不要使用Time :: 限定符。另外，不要在定义中使用关键字friend
程序示例
```
#include <iostream>
#include "FileName.h"
using namespace std;

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::operator+(const Time& t) const
{
	Time time;
	time.minutes = minutes + t.minutes;
	time.hours = hours + t.hours + time.minutes / 60;
	time.minutes %= 60;
	return time;
}

Time operator+(const Time& t, int d) 
{
	Time t1;
	int tt = t.hours * 60 + t.minutes + d;
	t1.hours = tt / 60;
	t1.minutes = tt % 60;
	return t1;
}

Time operator+(int d, const Time& t)
{
	return t + d;
}

void Time::Show() const
{
	cout << hours << ":" << minutes << '\n';
}

int main()
{
	Time t1(2, 30);
	Time t2(1, 30);
	Time tt;
	tt = t1 + t2;
	tt.Show();
	tt = t1 + 2;
	tt.Show();
}
```
有了上述声明和定义后，下面的语句:
A = 2.75 + B;
将转换为如下语句，从而调用刚才定义的非成员友元函数:
A = operator+ (2.75, B);

总之，类的友元函数是非成员函数，其访问权限与成员函数相同。

## 2.常用的友元：重载 << 运算符

假设tt是一个Time对象。为显示Time的值，前面使用的是Show()。然而，如果可以像下面这样操作将更好:
`cout << tt; // make cout recognize Time class?`
但是正常来说这样是无法输出的

### 1、<<的第一种重载版本
要使 Time 类知道使用cout，必须使用友元函数。这是什么原因呢？因为下面这样的语句使用两个对象，其中第一个是ostream类对象(cout):
`cout << tt;`

如果使用一个 *Time成员函数* 来重载 << ,Time对象将是第一个操作数,就像使用成员函数重载* 运算
符那样。这意味着必须这样使用 <<:
```
void Time::operator<<(std::ostream& oc)
{
	oc << hours << ":" << minutes << '\n';
}
...
tt << cout;// if operator << () were a Time member function
```

这样会令人迷惑。但通过使用友元函数，因为友元函数可以用于两个参数的运算符重载
像下面这样重载运算符并使用：
```
void operator<<(std::ostream& oc, const Time& t)
{
	oc << t.hours << ":" << t.minutes << '\n';
}
cout << tt;
```


### 2、<<的第二种重载版本
第一种方法存在一个问题，这样的语句可以正常工作
`cout << tt;`
但是这种实现不允许像通常那样将重新定义的<<运算符与cout一起使用
`cout << "Trip time: " << trip << " (Tuesday) \n"; // can't do`

在理解这样不可行的原因和如何做才能让重载可行，先了解关于cout操作的一点知识
```
int x=5;
int y=6;
cout<<x<<y;
```
C++从左到右读取输出语句，等同于：
 `(cout<<x)<<y`
 iostream中<<运算符要求左边是一个ostream对象，因为cout是ostream对象，所以表达式cout<<x满足条件。cout<<x位于<<y左侧，所以输出语句也要求改表达式是一个ostream对象。因此，ostream类将operator << ()函数实现为返回一个指向ostream 对象的引用。具体地说，它返回一个指向调用对象(这里是cout)的引用
 
 因此可以这样修改友元函数，把函数的typeName声明为ostream，让它返回ostream对象的引用
 ```
ostream & operator << (ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
 ```
 注意，返回类型是ostream&。这意味着该函数返回ostream对象的引用。因为函数开始执行时，程序传递了一个对象引用给它，这样做的最终结果是，函数的返回值就是传递给它的对象。也就是说,下面的语句:
`cout << tt;`
将被转换为下面的调用:
`operator << (cout, tt);`
这样一来，该语句就能正常工作
`cout << "Trip time: " << trip << " (Tuesday) \n"; // can do`