C++在处理内置[[4_类型转换||类型转换]]，将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。例如，下面的语句都将导致数值类型转换:
```
long count = 8;// int value 8 converted to type long
double time = 11;// int value 11 converted to type double
int side = 3.33;// double value 3.33 converted to type int 3
```
上述赋值语句都是可行的，因为在C++看来,各种数值类型都表示相同的东西——一个数字,同时C++包含用于进行转换的内置规则。例如3.33转换为int会丢失精度
C++不自动转换不兼容的类型。例如，下面的语句是非法的，因为左边是指针类型，而右边是数字:
`int * p = 10; // type clash`

但是，在无法转换时，可以使用强制类型转换
`int * p = (int *) 10; // ok, p and (int *) 10 both pointers`
上述语句将10转换为int指针类型，将地址设置为10，但是这种赋值是否有意义就是另一回事了

在C++中，类的类型转换分为**自动转换**（隐式转换）和**强制类型转换**（显式转换）。这两种方式允许程序员在不同类型之间进行灵活的转换，尤其是在用户自定义类中

## 1.使用构造函数进行自动转换
假设有一个类中有以下构造函数
`Stonewt (double lbs) // template for double-to-Stonewt conversion;`

```
Stonewt myCat;// create a Stonewt object
myCat = 19.6;// use Stonewt (double) to convert 19.6 to Stonewt
```

此时创建了一个对象并调用构造函数对其成员变量赋值，这一过程称为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。

只有接受一个参数的构造函数才能作为转换函数。下面的构造函数有两个参数，因此不能用来转换
类型:
`Stonewt (int stn, double lbs); // not a conversion function`
然而，如果给第二个参数提供默认值，它便可用于转换int:
`Stonewt (int stn, double 1bs = 0); // int-to-Stonewt conversion`

如果不希望发生隐式转换，可以使用explicit关键字修饰构造函数。例如：
`explicit Stonewt(double lbs);` ^06fd92

这将关闭上述示例中介绍的隐式转换，但仍然允许显式转换，即显式强制类型转换：
```
Stonewt myCat;// create a Stonewt object
myCat = 19.6;// not valid if Stonewt (double) is declared as explicit
mycat = Stonewt (19.6);// ok, an explicit conversion
mycat = (Stonewt) 19.6; // ok, old form for explicit typecast
```

什么时候使用构造函数隐式类型转换功能？
- 将Stonewt对象初始化为double值时；
- 将double值赋给Stonewt对象时；
- 将double值传递给接受Stonewt参数的函数时；
- 返回值被声明为Stonewt的函数试图返回double值时；
- 在上述任意一种情况下，使用可转换为double类型的内置类型时。


## 2.强制类型转换（转换函数）
强制类型转换通过用户定义的转换函数实现。转换函数的格式如下：
`operator typeName();`
转换函数**必须是类的成员函数，不能指定返回类型，也不能有参数**。例如，将类对象转换为double类型的函数可以这样定义：
```
class Stonewt {
public:
   operator double() const; // 转换为 double 类型
};
Stonewt obj(285.7);
double weight = double(obj); // 显式转换
```

当类定义了两种或更多的转换时可能会导致二义性问题。为避免此类问题，建议优先使用显式转换。

