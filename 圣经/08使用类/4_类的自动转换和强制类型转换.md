C++在处理内置[[4_类型转换||类型转换]]，将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。例如，下面的语句都将导致数值类型转换:
```
long count = 8;// int value 8 converted to type long
double time = 11;// int value 11 converted to type double
int side = 3.33;// double value 3.33 converted to type int 3
```
上述赋值语句都是可行的，因为在C++看来,各种数值类型都表示相同的东西——一个数字,同时C++包含用于进行转换的内置规则。例如3.33转换为int会丢失精度
C++不自动转换不兼容的类型。例如，下面的语句是非法的，因为左边是指针类型，而右边是数字:
`int * p = 10; // type clash`

但是，在无法转换时，可以使用强制类型转换
`int * p = (int *) 10; // ok, p and (int *) 10 both pointers`
上述语句将10转换为int指针类型，将地址设置为10，但是这种赋值是否有意义就是另一回事了

在C++中，类的类型转换分为**自动转换**（隐式转换）和**强制类型转换**（显式转换）。这两种方式允许程序员在不同类型之间进行灵活的转换，尤其是在用户自定义类中

## 1.使用构造函数进行自动转换
假设有一个类中有以下构造函数
`Stonewt (double lbs) // template for double-to-Stonewt conversion;`




