运算符重载是一种形式的C++多态，用户能够定义多个名称相同但特征标(参数列表)不同的函数的。这被称为函数重载或函数多态，这样可以使用同名函数完成一些操作，即使这种操作被用于不同数据类型。运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。实际上，很多C++(也包括C语言)运算符已经被重载。例如，将* 运算符用于地址，将得到存储在这个地址中的值；但将它用于两个数字时得到的将是它们的乘积。C++根据操作数的数目和类型来决定采用哪种操作。

要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下:
`operator 'op' (argument-list)`
例如，operator+()将会重载+运算符，operator*()将会重载* 运算符。op必须是有效的C++运算符,不能虚构一个新的符号。例如，不能有operator@()这样的函数，因为C++中没有@运算符。然而，`operator[]()`函数将重载[]运算符,因为[]是数组索引运算符


## 计算时间：一个运算符重载示例
如果今天早上在Priggs的账户上花费了2小时35分钟，下午又花费了2小时40分钟，则总共花了多少时间呢？这个示例与加法概念很吻合，但要相加的单位(小时与分钟的混合)与内置类型不匹配
可用一个方法来处理加法的Time类。首先使用一个名为Sum()的常规方法，然后将其转换为重载运算符

 .h
```
#pragma once

class Time
{
public:
	Time();
	Time(int h, int m = 0);
	void AddMin(int m);
	void AddHr(int h);
	void Reset(int h = 0, int m = 0);
	Time Sum(const Time& t) const;
	void Show() const;
private:
	int hours;
	int minutes;
};

```

 .cpp
```
#include <iostream>
#include "FileName.h"
using namespace std;

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

Time Time::Sum(const Time& t) const
{
	Time time;
	time.minutes = minutes + t.minutes;
	time.hours = hours + t.hours + time.minutes / 60;
	time.minutes %= 60;
	return time;
}

void Time::Show() const
{
	cout << hours << ":" << minutes << '\n';
}

int main()
{
	Time t1(2, 30);
	Time t2(1, 30);
	Time tt;
	tt = t1.Sum(t2);
	tt.Show();
}
```

==警告==：不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失,引用将指向不存在的数据。


### 1.添加加法运算符
将Time类转换为重载的加法运算符很容易，只要将Sum()的名称改为operator+()即可。这样做是对
的，只要把运算符(这里为+)放到operator的后面，并将结果用作方法名即可。在这里，可以在标识符中使用字母、数字或下划线之外的其他字符

```
Time Time::operator+(const Time& t) const
{
	Time time;
	time.minutes = minutes + t.minutes;
	time.hours = hours + t.hours + time.minutes / 60;
	time.minutes %= 60;
	return time;
}
```

和Sum()一样，operator+()也是由Time对象调用的，它将第二个Time对象作为参数，并返回一个Time对象。因此，可以像调用Sum()那样来调用operator+()方法：
`tt = t1.operator+(t2);// function notation`

但将该方法命令为operator+()后，也可以使用运算符表示法：
`tt = t1 + t2;// operator notation`

这两种表示法都将调用operator+()方法。注意，在运算符表示法中，运算符左侧的对象(这里为t1)是调用对象，运算符右边的对象(这里为t2)是作为参数被传递的对象


### 2.重载限制
多数C++运算符都可以用这样的方式重载。重载的运算符(有些例外情况)不必是成员函数，但必须至少有一个操作数是用户定义的类型。下面详细介绍C++对用户定义的运算符重载的限制。
1. 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符(-)重载为计算两个double值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行

2. 使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符(%)重载成使用一个操作数:
   ```
   int x;
   Time shiva;
   % x;// invalid for modulus operator
   % shiva;// invalid for overloaded operator
   ```
   同样,不能修改运算符的优先级。因此,如果将加号运算符重载成将两个类相加,则新的运算符与原来的加号具有相同的优先级。

3. 不能创建新运算符。例如,不能定义operator ** ()函数来表示求幂。
4. 不能重载下面的运算符：
	 sizeof运算符
	 . 成员运算符
	 `*`成员指针运算符
	 :: 作用域解析运算符
	?; 条件运算符
	typeid 一个RTTI运算符
	const_cast:强制类型转换运算符
	dynamic_cast:强制类型转换运算符
	reinterpret_cast:强制类型转换运算符
	static_cast:强制类型转换运算符 
5. 大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载
	=: 赋值运算符。
	():函数调用运算符。
	[] :下标运算符。
	->:通过指针访问类成员的运算符。

