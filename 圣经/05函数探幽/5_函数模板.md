函数模板是通用的函数描述，它们使用泛型来定义函数
例如，现在有一个函数，功能是交换两个int值，假设要交换两个double值；一种方式是复制原来的复制原来的代码，用double替换所有的int，但是这样太麻烦了
此时，C++函数模板功能能自动完成这一过程，可以节省时间，而且更可靠
函数模板允许以任意类型的方式定义函数，例如：
```
template<typename AnyType>
void Swap(AnyType& a, AnyType& b)
{
	AnyType t;
	t = a;
	a = b;
	b = t;
}
```
第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的并且template和函数声明要组合出现。另外必须使用尖括号。类型名可以任意选择，此时为AnyType。余下的代码交换两个AnyType
模板不创建任何函数，只是告诉编译器如何定义函数，现在这种情况下：需要交换int类型参数时，编译器将按模板模式创建这样的函数，并用int代替AnyType

==提示==:如果需要多个将同一种算法用于不同类型的函数，请使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不使用class

## 1.重载（函数）的模板
可以和上述函数一样，新建一个交换模板，交换两个数组中的元素：
```
template<typename AnyType>
void Swap(AnyType* a, AnyType* b, int n)
{
	AnyType t;
	for (int i = 0; i < n; i++)
	{
		t = a[i];
		a[i] = b[i];
		b[i] = t;
	}
}
```
此时编译器将根据传入的参数类型选择不同的函数
在这个函数模板中最后一个参数类型是int，不是泛型；所以，并非所有的模板参数都必须是模板参数类型


## 2.模板的局限性
如果有一下模板函数
```
template <typename T>
void f (T a, T b)
{ ... }
```
通常，代码假定可执行哪些操作；如果我在函数体里进行一下操作是传入参数无法执行的（如果传入参数是结构体，我执行比较操作，这是非法的）。总之，编写的模板函数很可能无法处理某些类型，但是为特定类型提供具体化的模板定义，就可以解决此类问题，如下


## 3.显式具体化
假设有以下结构体：
```
struct job
{
	char name [40];
	double salary;
	int floor;
}
```
如果我想交换两个结构体中的内容，则Swap就可以实现，但是如果只想交换double和int，就需要不同的代码，同时函数参数不可变，因此无法用函数重载来提供其他的代码
然而，可以提供一个具体化函数定义——称为显式具体化(explicit specialization)，其中包含所需的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板
### 第三代具体化（ISO/ANSI C++标准）
试验其他具体化方法后，C++98标准选择了下面的方法。
- 对于给定的函数名,可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
- 显式具体化的原型和定义应以template<>打头,并通过名称来指出类型。
- 具体化优先于常规模板,而非模板函数优先于具体化和常规模板。
下面是用于交换job结构的非模板函数、模板函数和具体化的原型:
```
// non template function prototype
void Swap(job &, job &) ;

// template prototype
template <typename T>
void Swap(T &, T &) ;

// explicit specialization for the job type
template <> void Swap<job>(job &, job &) ;
```
如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。例如，在下面的代码中，第一次调用Swap()时使用通用版本，而第二次调用使用基于job类型的显式具体化版本
```
double u, v;
...
Swap(u,v); // use template
job a, b;
...
Swap(a,b); // use void Swap<job>(job &, job &)
```


## 4.实例化和具体化
在代码中包含的函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时,得到的是模板实例(instantiation)。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化
现在C++还允许显式实例化：这意味着可以直接命令编译器创建特定的实例,如`Swap<int>()`。其语法是，声明所需的种类——用<>符号指示类型，并在声明前加上关键字template