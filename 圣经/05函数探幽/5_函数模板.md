函数模板是通用的函数描述，它们使用泛型来定义函数
例如，现在有一个函数，功能是交换两个int值，假设要交换两个double值；一种方式是复制原来的复制原来的代码，用double替换所有的int，但是这样太麻烦了
此时，C++函数模板功能能自动完成这一过程，可以节省时间，而且更可靠
函数模板允许以任意类型的方式定义函数，例如：
```
template<typename AnyType>
void Swap(AnyType& a, AnyType& b)
{
	AnyType t;
	t = a;
	a = b;
	b = t;
}
```
第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的并且template和函数声明要组合出现。另外必须使用尖括号。类型名可以任意选择，此时为AnyType。余下的代码交换两个AnyType
模板不创建任何函数，只是告诉编译器如何定义函数，现在这种情况下：需要交换int类型参数时，编译器将按模板模式创建这样的函数，并用int代替AnyType

==提示==:如果需要多个将同一种算法用于不同类型的函数，请使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不使用class

## 1.重载（函数）的模板
可以和上述函数一样，新建一个交换模板，交换两个数组中的元素：
```
template<typename AnyType>
void Swap(AnyType* a, AnyType* b, int n)
{
	AnyType t;
	for (int i = 0; i < n; i++)
	{
		t = a[i];
		a[i] = b[i];
		b[i] = t;
	}
}
```
此时编译器将根据传入的参数类型选择不同的函数
在这个函数模板中最后一个参数类型是int，不是泛型；所以，并非所有的模板参数都必须是模板参数类型


## 2.模板的局限性
如果有一下模板函数
```
template <typename T>
void f (T a, T b)
{ ... }
```
通常，代码假定可执行哪些操作；如果我在函数体里进行一下操作是传入参数无法执行的（如果传入参数是结构体，我执行比较操作，这是非法的）。总之，编写的模板函数很可能无法处理某些类型，但是为特定类型提供具体化的模板定义，就可以解决此类问题，如下


## 3.显式具体化
假设有以下结构体：
```
struct job
{
	char name [40];
	double salary;
	int floor;
}
```
如果我想交换两个结构体中的内容，则Swap就可以实现，但是如果只想交换double和int，就需要不同的代码，同时函数参数不可变，因此无法用函数重载来提供其他的代码
然而，可以提供一个具体化函数定义——称为显式具体化(explicit specialization)，其中包含所需的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板
