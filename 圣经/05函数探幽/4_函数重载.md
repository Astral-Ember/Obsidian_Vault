函数重载可以有多个同名的函数，使用不同的参数列表，完成相同的工作
函数重载的关键是函数的参数列表——也称为函数特征标(function signature)。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。例如
```
void print (const char * str, int width);// #1
void print (double d, int width);// #2
void print (long 1, int width);// #3
void print (int i, int width);// #4
void print (const char *str) ;// #5
```
使用print()函数时，编译器将根据所采取的用法使用有相应特征标的原型：
```
print ("Pancakes", 15);// use #1
print ("Syrup") ;// use #5
print (1999.0, 10);// use #2
print (1999, 12);// use #4
print (1999L, 15) ;// use #3
```

使用被重载的函数时，需要在函数调用中使用正确的参数类型
- 如果我声明一个unsigned int类型的变量，并作为第一个参数传入到函数中。此时不与任意原型匹配。但是没有匹配的原型并不会自动停止使用其中的某个函数，因为C++将尝试使用标准类型转换强制进行匹配。如果#2作为唯一的原型，会将unsigned int强制转换为double并使用，但是此时有3个将数字作为第一个参数的原型，所以C++将拒绝这种函数调用，并视为错误
- 一些看起来彼此不同的特征标是不能共存的（引用这一块）
  `double cube (double x);`
  `double cube (double & x) ;`
  如果使用了例如`cout<<cube(x)`
  这种情况下，参数x与两种原型都匹配，因此编译器无法确定究竟应使用哪个原型，为避免这种情况，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。

## 何时使用函数重载
不要滥用函数重载。仅当函数基本上执行相同的任务，但使用不同形式的数据时使用重载
当然，在一定情况下使用默认参数也可以实现同样的目的
```
char * left (const char * str, unsigned n) ;// two arguments
char * left (const char * str) ;// one argument
```
使用一个带默认参数的函数要简单些。只需编写一个函数(而不是两个函数)，程序也只需为一个函数
(而不是两个)请求内存；需要修改函数时，只需修改一个。然而，如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下,应该使用函数重载

