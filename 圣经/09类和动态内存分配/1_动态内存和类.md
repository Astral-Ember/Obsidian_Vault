C++使用new和delete运算符来动态分配内存，但是在类中使用这些运算符会导致很多新的编程问题。在这种情况下，析构函数必不可少，有的时候还必须重载运算符

## 特殊成员函数
C++自动提供了下面这些成员函数:
- 默认构造函数，如果没有定义构造函数;
- 默认析构函数，如果没有定义;
- 复制构造函数，如果没有定义;
- 赋值运算符，如果没有定义;
- 地址运算符，如果没有定义。
### 1、[[2_类的构造函数和析构函数#^a1f24a|默认构造函数]]
如果没有提供任何构造函数，C++将创建默认构造函数。例如，假如定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数:
`Klunk: :Klunk () { } // implicit default constructor`
也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用构造函数：
`Klunk lunk;// invokes default constructor`
默认构造函数使Lunk类似于一个常规的自动变量，也就是说，它的值在初始化时是未知的。

但是如果定义了构造函数，C++就不会定义默认构造函数。如果希望在创建对象时不显式地对它初始化（列表初始化），则必须显式地定义默认构造函数。这种构造函数没有任何参数，但是可以用来初始化一些值：
```
Klunk::Klunk() // explicit default constructor
{
	k1 = 1;
	...
}
```
带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值即可
但是只能有一个默认构造函数，不能这样做：
```
Klunk() { klunk_ct = o;}// constructor #1
Klunk (int n = 0) { klunk ct = n; }// ambiguous constructor #2
```
因为这种情况下会导致二义性

### 2、复制（拷贝）构造函数
复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中(包括按值传
递参数)，而不是常规的赋值过程中。类的复制构造函数原型通常如下:
`Class_name(const Class_name &);`
它接受一个指向类对象的常量引用作为参数。例如，Time类的复制构造函数的原型如下:
`StringBad(const StringBad &);` 
对于复制构造函数，需要知道两点:何时调用和有何功能。
==注意==：如果类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。然而，如果类中包含指针变量并且有动态内存分配，则必须定义一个拷贝构造函数
### 3、何时调用复制构造函数
新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数:
```
StringBad ditto(motto);// calls StringBad(const StringBad &)
StringBad metoo = motto; // calls StringBad(const StringBad &)
StringBad also = StringBad(motto);// calls StringBad(const StringBad &)
StringBad * pStringBad = new StringBad(motto);// calls StringBad(const StringBad &)
```
其中中间的2种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用 motto初始化一个匿名对象，并将新对象的地址赋给pstring指针。

### 4、默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。
`StringBad metoo = motto;`
等价于
```
StringBad metto;
metto.str=motto.str;
metto.len=motto.len;
```
如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数不受影响，因为它们属于整个类，而不是各个对象

