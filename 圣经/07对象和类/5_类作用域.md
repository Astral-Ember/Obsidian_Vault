[[2_存储连续性、作用域和链接性|此前]]介绍了全局（文件）作用域和局部（代码块）作用域。可以在全局变量所属文件的任何地方使用它，而局部变量只能在其所属的代码块中使用。函数名称的作用域也可以是全局的，但不能是局部的。
C++类引入了一种新的作用域：类作用域。
在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说,要调用公有成员函数，必须通过对象

## 1.作用域为类的常量
如果在类中需要一个常量作为数组的长度，通常想法是声明一个const变量并用在数组长度声明中
```
private:
	const int a = 10;
	int arr[a];
```
会有报错 “因读取超过生命周期的变量而失败”
这是行不通的，因为声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，将没有用于存储值的空间，然而，有两种方式可以实现这个目标,并且效果相同

第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。也就是说，可以这样开始Bakery声明:
```
class Bakery
{
private:
enum {Months = 12};
double costs [Months] ;

...
```
注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。另外，Months只是一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用12来替换它

第二种方式是：C++提供了另一种在类中定义常量的方式——使用关键字 static:
```
class Bakery
{
private:
static const int Months = 12;
double costs [Months];
...
```
这将创建一个名为 Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中

## 2.作用域内枚举
传统的枚举存在一些问题，其中之一是两个枚举定义中的枚举量可能发生冲突。假设有一个处理鸡蛋和T恤的项目，其中可能包含类似下面这样的代码：
```
enum egg {Small, Medium, Large, Jumbo};
enum t_shirt {Small, Medium, Large, Xlarge};
```
这将无法通过编译，因为egg Small和t_shirt Small位于相同的作用域内，它们将发生冲突。为避免这种问题，C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似于下面这样:
```
enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Xlarge};
```


也可使用关键字 struct代替class。无论使用哪种方式，都需要使用枚举名来限定枚举量:
```
egg choice = egg :: Large;// the Large enumerator of the egg enum
t_shirt Floyd = t shirt :: Large; // the Large enumerator of the t shirt enum
```

枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生名称冲突了