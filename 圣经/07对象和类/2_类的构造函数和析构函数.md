```
#include <iostream>
using namespace std;

class Stock // class declaration
{
private:
	std::string company;
	long shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	void acquire(const std::string& co, long n, double pr);
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show();
	// note semicolon at the end
};
```
构造函数可用用来初始化成员变量
构造函数名称与类名相同，例如，Stock类一个可能的构造函数是名为Stock()的成员函数。构造函数的原型和函数头有一个有趣的特征——虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型

## 1.声明和定义构造函数
现在需要创建Stock的构造函数。由于需要为Stock对象提供3个值，因此应为构造函数提供3个参数。
原型如下所示:
`Stock(const string & co, long n = 0, double pr = 0.0);// constructor prototype with some default arguments`
}

下面是构造函数的一种可能定义:
```
// constructor definition
Stock :: Stock(const string & co, long n, double pr)
{
company = co;

if (n < 0)
{
	std :: cerr << "Number of shares can't be negative; "
				<< company << " shares set to 0.\n";
	shares = 0;
}
	else
		shares = n;
	share_val = pr;
	set_tot ();
}
```

程序声明对象时，将自动调用构造函数。

## 2.使用构造函数
C++提供了两种使用构造函数来初始化对象的方式。第一种方式是显式地调用构造函数:
`Stock food = Stock("World Cabbage", 250, 1.25);`
另一种方式是隐式地调用构造函数:
`Stock garment ("Furry Mason", 50, 2.5);`
每次创建类对象(甚至使用new动态分配内存)时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法:
`Stock *pstock = new Stock ("Electroshock Games", 18, 19.0);`

==注意==：无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。因此构造函数被用来创建对象，而不能通过对象来调用。
## 3.默认构造函数
默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。

对于 Stock 类来说，默认构造函数可能如下：
`Stock::Stock(){ }`
当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后,程序员就必须为它提供默认构造函数。如果提供了非默认构造函数(如`Stock(const char *co, int n,doublepr)`),但没有提供默认构造函数，则下面的声明将出错:
`Stock stock1; // not possible with current constructor`

这样做的原因可能是想禁止创建未初始化的对象。然而，如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值：
`Stock(const string & co = "Error", int n = 0, double pr = 0.0);`
另一种方法是通过函数重载来定义一个没有参数的构造函数
`Stock();`
由于只能有一个默认构造函数，因此不要同时采用这两种方式


## 4.析构函数
用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数——析构函数。析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存

和构造函数一样，析构函数的名称也很特殊：在类名前加上~。因此，Stock类的析构函数为`~Stock()`  另外，和构造函数一样，析构函数也可以没有返回值和声明类型。与构造函数不同的是，析构函数没有参数，因此Stock析构函数的原型必须是这样的:`~Stock()`

由编译器决定什么时候调用析构函数，通常不应在代码中显式地调用析构函数
如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。
如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时(该对象是在其中定义的)自动被调用。
如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。
最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数

## 5.小结
构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的特征标(参数列表)都不同。另外，构造函数没有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配

默认构造函数没有参数，因此如果创建对象时没有进行显式地初始化，则将调用默认构造函数。如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值

就像对象被创建时程序将调用构造函数一样，当对象被删除时，程序将调用析构函数。每个类都只能有一个析构函数。析构函数没有返回类型(连void都没有)，也没有参数，其名称为类名称前加上~

