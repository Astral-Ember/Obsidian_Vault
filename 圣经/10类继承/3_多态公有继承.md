RatedPlayer继承示例很简单。派生类对象使用基类的方法，而未做任何修改。然而,可能会遇到这样的情况，即希望同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应取决于调用该方法的对象。这种较复杂的行为称为多态——具有多种形态，即同一个方法的行为随上下文而异。有两种重要的机制可用于实现多态公有继承：
- 在派生类中重新定义基类的方法
- 使用虚方法

使用关键字：virtual，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法
例如，如果ViewAcct()不是虚函数：
```
// behavior with non-virtual ViewAcct()
// method chosen according to reference type
Brass dom("Dominic Banker", 11224, 4183.45) ;
BrassPlus dot ("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct ();// use Brass :: ViewAcct ()
b2_ref.ViewAcct ();// use Brass: : ViewAcct ()
```
引用变量的类型为Brass，所以选择了Brass :: ViewAccount()。使用Brass指针代替引用时，行为将与此类似。

如果ViewAcct()是虚函数：
```
// behavior with virtual ViewAcct ()
// method chosen according to object type
Brass dom("Dominic Banker", 11224, 4183.45) ;
BrassPlus dot ("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1 ref.ViewAcct();// use Brass :: ViewAcct ()
b2 ref.ViewAcct();// use BrassPlus: : ViewAcct ()
```
这里两个引用的类型都是Brass，但b2_ref 引用的是一个 BrassPlus 对象，所以使用的是BrassPlus :: ViewAcct()。使用Brass指针代替引用时，行为将类似。

定义虚函数这种行为非常方便，因此，经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法
==注意==：如果要在派生类中重新定义基类的方法,通常应将基类方法声明为虚的。这样，程序将根据对
象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例

在派生类方法中，如果想调用基类方法，标准技术是使用作用域解析运算符（::）来调用基类方法。