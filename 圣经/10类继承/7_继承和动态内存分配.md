继承是怎样与动态内存分配（使用new和delete）进行互动的呢？例如，如果基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现呢？这个问题的答案取决于派生类的属性。如果派生类也使用动态内存分配，那么就需要学习几个新的小技巧。下面来看看这两种情况。

## 1.第一种情况：派生类不适用new
假设基类使用了动态内存分配：
```
// Base Class Using DMA
class baseDMA
{
private:
	char * label;
	int rating;

public:
	baseDMA (const char * 1 = "null", int r = 0) ;
	baseDMA (const baseDMA & rs) ;
	virtual ~baseDMA();
	baseDMA & operator=(const baseDMA & rs) ;
...
};
```
声明中包含了构造函数使用new时需要的特殊方法：析构函数、复制构造函数和重载赋值运算符。
现在，从baseDMA派生出lackDMA类，而后者不使用new，也未包含其他一些不常用的、需要特殊处理的设计特性：
```
// derived class without DMA
class lacksDMA :public baseDMA
{
private:
	char color [40];
public:
...
};
```
是否需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符呢？
**不需要**

在这种情况下，首先，lacksDMA成员不需要任何特殊操作，所以只需要默认析构函数即可；
其次，关于默认复制构造函数，此类函数执行成员复制，但是对于动态分配内存来说并不适用，但是对于继承的lacksDMA成员是合适的，lacksDMA类的默认复制构造函数使用显式baseDMA复制构造函数来复制lacksDMA对昂的baseDMA部分；
最后，对于赋值，类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件赋值，所以默认赋值运算符也是合适的。

## 2.第二种情况：派生类使用new
假设派生类使用了new
```
class hasDMA :public baseDMA
{
private:
	char * style; // use new in constructors
public:
...
};
```
在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符。下面依次考虑这些
方法。
派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此，hasDMA析构函数必须释放指针style管理的内存，并依赖于baseDMA的析构函数来释放指针label管理的内存。
```
baseDMA :: ~baseDMA() // takes care of baseDMA stuff
{
	delete [] label;
}
hasDMA: : ~hasDMA ()// takes care of hasDMA stuff
{
	delete [] style;
}
```
接下来看复制构造函数。BaseDMA的复制构造函数遵循用于char数组的常规模式，即使用strlen()来获悉存储C-风格字符串所需的空间、分配足够的内存(字符数加上存储空字符所需的1字节)并使用函数strcpy()将原始字符串复制到目的地：
```
baseDMA: :baseDMA (const baseDMA & rs)
{
	label = new char [std :: strlen(rs.label) + 1];
	std: :strcpy(label, rs.label) ;
	rating = rs.rating;
}
```
hasDMA 复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的baseDMA数据：
```
hasDMA: :hasDMA (const hasDMA & hs)
: baseDMA (hs)
{
style = new char [std::strlen(hs.style) + 1];
std :: strcpy(style, hs.style) ;
}
```
成员初始化列表把hasDMA的引用传递给baseDMA的复制构造函数，由于基类引用可以指向派生类，因此，baseDMA复制构造函数将使用hasDMA参数的baseDMA部分构造新对象的baseDMA部分

由于hasDMA也使用动态内存分配，所以它也需要一个显式赋值运算符。作为hasDMA的方法，它只能直接访问hasDMA的数据。然而，派生类的显式赋值运算符必须负责所有继承的baseDMA基类对象的赋值，可以通过显式调用基类赋值运算符来完成这项工作，如下所示：
```
hasDMA & hasDMA :: operator=(const hasDMA & hs)
{
	if (this == &hs)
		return *this;
	baseDMA: : operator=(hs); // copy base portion	
	delete [] style;// prepare for new style
	style = new char [std :: strlen(hs.style) + 1] ;
	std: :strcpy(style, hs.style) ;
	return *this;
```

总之，当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。