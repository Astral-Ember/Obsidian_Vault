## 1.编译器生成的成员函数
编译器会自动生成一些公有成员函数——[[1_动态内存和类#^2d509b|特殊成员函数]]。这表明这些特殊成员函数很重要：

### 1、[[2_类的构造函数和析构函数#^a1f24a|默认构造函数]]
默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将定义默认构造函数，这样才能创建对象。
自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数
另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有构造函数，将导致编译阶段报错
如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。
提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值

### 2、[[1_动态内存和类#^8a4187|复制（拷贝）构造函数]]
复制构造函数接受其所属类的对象作为参数。例如，Star类的复制构造函数的原型如下:
`Star(const Star &);`
在下述情况下，将使用复制构造函数：
- 将新对象初始化为一个同类对象;
- 按值将对象传递给函数;
- 函数按值返回对象;
- 编译器生成临时对象
如果程序没有使用(显式或隐式)复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。
在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深复制(参
见baseDMA类示例)，或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数（显式的定义复制构造函数）

### 3、赋值运算符