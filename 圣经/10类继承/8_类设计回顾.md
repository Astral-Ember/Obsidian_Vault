## 1.编译器生成的成员函数
编译器会自动生成一些公有成员函数——[[1_动态内存和类#^2d509b|特殊成员函数]]。这表明这些特殊成员函数很重要：
### 1、[[2_类的构造函数和析构函数#^a1f24a|默认构造函数]]
默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将定义默认构造函数，这样才能创建对象。
自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数
另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有构造函数，将导致编译阶段报错
如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。
提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值
### 2、[[1_动态内存和类#^8a4187|复制（拷贝）构造函数]]
复制构造函数接受其所属类的对象作为参数。例如，Star类的复制构造函数的原型如下:
`Star(const Star &);`
在下述情况下，将使用复制构造函数：
- 将新对象初始化为一个同类对象;
- 按值将对象传递给函数;
- 函数按值返回对象;
- 编译器生成临时对象
如果程序没有使用(显式或隐式)复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。
在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深复制(参
见baseDMA类示例)，或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数（显式的定义复制构造函数）
### 3、赋值运算符
默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值:
```
Star sirius;
Star alpha = sirius;// initialization (one notation)
Star dogstar;
dogstar = sirius;// assignment
```
编译器不会生成将一种类型赋给另一种类型的赋值运算符。如果希望能够将字符串赋给Star对象，则方法之一是显式定义下面的运算符：
`Star & Star :: operator=(const char *) { ... }`
另一种方法是使用转换函数（参见下一节中的“转换”小节）将字符串转换成Star对象，然后使用将Star 赋给 Star的赋值函数。第一种方法的运行速度较快，但需要的代码较多，而使用转换函数可能导致编译器出现混乱

## 2.其他的类方法
定义类时，还需要注意以下几点：
### 1、构造函数
构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在
### 2、析构函数
一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数
### 3、转换
使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。例如，下述Star类的构造函数原型:
```
Star(const char *);// converts char * to Star
Star (const Spectral &, int members = 1); // converts Spectral to Star
```
将可转换的类型传递给以类为参数的函数时,将调用转换构造函数。例如,在如下代码中:
```
Star north;
north = "polaris";
```
第二条语句将调用 Star :: operator=(const Star*)函数，使用Star :: star(const char * )生成一个 Star对象，该对象将被用作上述赋值运算符函数的参数。这里假设没有定义将char* 赋给Star的赋值运算符。
### 4、按值传递对象与传递引用
通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。这样做的原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为 const引用
按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。这在[[7_继承和动态内存分配#^e559ad|前面]]介绍过
### 5、[[3_有关返回对象的说明|返回对象和返回引用]]
有些类方法返回对象。有些成员函数直接返回对象，而另一些则返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用：
首先，在编码方面，直接返回对象与返回引用之间唯一的区别在于函数原型和函数头:
```
Star noval(const Star &) ;// returns a Star object
Star & nova2(const Star &) ;// returns a reference to a Star
```
其次，应返回引用而不是返回对象的的原因在于，返回对象涉及生成返回对象的临时副本，这是调用函数的程序可以使用的副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可节省时间和内存。直接返回对象与按值传递对象相似：它们都生成临时副本。同样，返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作
然而，并不总是可以返回引用。函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本（生命周期问题）
通用的规则是：
- 如果函数返回在函数中创建的临时对象，则不要使用引用。
- 如果函数返回的是通过引用或指针传递给它的对象,则应按引用返回对象
### 6、使用const
使用const时应特别注意。可以用它来确保方法不修改参数：
`Star: : Star(const char * s) { ... } //won't change the string to which s points`
可以使用[[2_类的构造函数和析构函数#^852cc1|const来确保方法不修改调用它的对象]]:
`void Star :: show() const{ ... } // won't change invoking object`
注意，如果函数将参数声明为指向const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改

## 3.公有继承的考虑因素
通常，在程序中使用继承时，有很多问题需要注意。

### 1、is-a关系
要遵循is-a关系。如果派生类不是一种特殊的基类，则不要使用公有派生。例如，不应从Brain类派生出Programmer类。如果要指出程序员有大脑，应将Brain类对象作为Programmer类的成员。
在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。
==注意==：表示is-a关系的方式之一是,无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象（[[4_静态联编和动态联编#^ddb479|向上强制转换]]）。另外，反过来是行不通的，即不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。这种显式类型转换（向下强制转换）可能有意义，也可能没有，这取决于类声明

### 2、为什么不能被继承
构造函数是不能继承的，也就是说，创建派生类对象时，[[1_一个简单的基类#^e17773|必须调用派生类的构造函数]]。然而，派生类构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。C++11新增了一种能够继承构造函数的机制（using），但默认仍不继承构造函数。
析构函数也是不能继承的。然而，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常，对于基类，其析构函数应设置为虚的。
赋值运算符是不能继承的，原因很简单。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参。赋值运算符确实有一些有趣的特征

### 3、赋值运算符
如果类构造函数使用new来初始化指针，则需要提供一个显式赋值运算符。因为对于派生对象的基类部分，C++将使用基类的赋值运算符，所以不需要为派生类重新定义赋值运算符，除非它添加了需要特别留意的数据成员。例如，baseDMA类显式地定义了赋值，但派生类lackDMA使用为它生成的隐式赋值运算符。
然而，如果[[7_继承和动态内存分配#^5d6a17|派生类使用了new]]，则必须提供显式赋值运算符。必须给类的每个成员提供赋值运算符，而不仅仅是新成员

### 4、[[5_访问控制：protected|私有成员与保护成员]]
对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。

### 5、[[4_静态联编和动态联编#^a50ee5|虚方法]]
设计基类时，必须确定是否将类方法声明为虚的。如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用动态联编（==注意==：动态联编一般在指向对象的引用或指针来调用虚方法时启用）；如果不希望重新定义方法，则不必将其声明为虚的

### 6、[[4_静态联编和动态联编#^c07cf7|析构函数]]
正如前面介绍的，基类的析构函数应当是虚的。这样，当通过指向对象的基类指针或引用来删除派生对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。

### 7、[[4_静态联编和动态联编#^575fd7|友元函数]]
由于友元函数并非类成员，因此不能继承。然而，可能希望派生类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将，派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数：
`const className &`
```
ostream & operator << (ostream & os, const hasDMA & hs)
{
	//type cast to match operator << (ostream & , const baseDMA &)
	os << (const baseDMA &) hs;
	os << "Style: " << hs.style << endl;
	return os;
}
```

### 8、有关使用基类方法的说明
以公有方式派生的类的对象可以通过多种方式来使用基类的方法。
