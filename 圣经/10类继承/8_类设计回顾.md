## 1.编译器生成的成员函数
编译器会自动生成一些公有成员函数——[[1_动态内存和类#^2d509b|特殊成员函数]]。这表明这些特殊成员函数很重要：

### 1、[[2_类的构造函数和析构函数#^a1f24a|默认构造函数]]
默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将定义默认构造函数，这样才能创建对象。
自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数
另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有构造函数，将导致编译阶段报错
如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。
提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值

### 2、[[1_动态内存和类#^8a4187|复制（拷贝）构造函数]]
复制构造函数接受其所属类的对象作为参数。例如，Star类的复制构造函数的原型如下:
`Star(const Star &);`
在下述情况下，将使用复制构造函数：
- 将新对象初始化为一个同类对象;
- 按值将对象传递给函数;
- 函数按值返回对象;
- 编译器生成临时对象
如果程序没有使用(显式或隐式)复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。
在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深复制(参
见baseDMA类示例)，或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数（显式的定义复制构造函数）

### 3、赋值运算符
默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值:
```
Star sirius;
Star alpha = sirius;// initialization (one notation)
Star dogstar;
dogstar = sirius;// assignment
```
编译器不会生成将一种类型赋给另一种类型的赋值运算符。如果希望能够将字符串赋给Star对象，则方法之一是显式定义下面的运算符：
`Star & Star :: operator=(const char *) { ... }`
另一种方法是使用转换函数（参见下一节中的“转换”小节）将字符串转换成Star对象，然后使用将Star 赋给 Star的赋值函数。第一种方法的运行速度较快，但需要的代码较多，而使用转换函数可能导致编译器出现混乱
## 2.其他的类方法
定义类时，还需要注意以下几点：
### 1、构造函数
构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在

### 2、析构函数
一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数

### 3、转换
使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。例如，下述Star类的构造函数原型:
```
Star(const char *);// converts char * to Star
Star (const Spectral &, int members = 1); // converts Spectral to Star
```
将可转换的类型传递给以类为参数的函数时,将调用转换构造函数。例如,在如下代码中:
```
Star north;
north = "polaris";
```
第二条语句将调用 Star :: operator=(const Star*)函数，使用Star :: star(const char * )生成一个 Star对象，该对象将被用作上述赋值运算符函数的参数。这里假设没有定义将char* 赋给Star的赋值运算符。

