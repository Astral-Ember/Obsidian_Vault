继承是怎样与动态内存分配（使用new和delete）进行互动的呢？例如，如果基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现呢？这个问题的答案取决于派生类的属性。如果派生类也使用动态内存分配，那么就需要学习几个新的小技巧。下面来看看这两种情况。

## 1.第一种情况：派生类不适用new
假设基类使用了动态内存分配：
```
// Base Class Using DMA
class baseDMA
{
private:
	char * label;
	int rating;

public:
	baseDMA (const char * 1 = "null", int r = 0) ;
	baseDMA (const baseDMA & rs) ;
	virtual ~baseDMA();
	baseDMA & operator=(const baseDMA & rs) ;
...
};
```
声明中包含了构造函数使用new时需要的特殊方法：析构函数、复制构造函数和重载赋值运算符。
现在，从baseDMA派生出lackDMA类，而后者不使用new，也未包含其他一些不常用的、需要特殊处理的设计特性：
```
// derived class without DMA
class lacksDMA :public baseDMA
{
private:
	char color [40];
public:
...
};
```
是否需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符呢？
**不需要**
