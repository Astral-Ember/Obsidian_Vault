程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在C++中，由于函数重载的缘故，编译器必须查看函数参数以及函数名才能确定使用哪个函数。C++编译器可以在编译过程中完成这种联编，在编译过程中进行联编被称为静态联编。然而，虚函数使这项工作变得更困难，所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编

## 1.指针和引用类型的兼容性
在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的
通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型:
```
double x = 2.5;
int * pi = &x;// invalid assignment, mismatched pointer types
long & rl = x;// invalid assignment, mismatched reference type
```
指向基类的引用或指针可以引用派生类对象,而不必进行显式类型转换。例如,下面的初始化是允许的:
```
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;// ok
Brass & rb = dilly;// ok
```
将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，BrassPlus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。同时，向上强制转换是可传递的，就是说如果派生类派生出了一个新的派生类，则基类的指针或引用可以引用三类的所有对象
相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类

对于使用基类**引用**或**指针**作为参数的函数调用，将进行向上转换；如果是值传递，只会将派生类对象的基类部分传递给函数
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。

## 2.虚成员函数和动态联编


.来回顾一下使用引用或指针调用方法的过程:
```
BrassPlus ophelia;// derived-class object
Brass * bp;// base-class pointer
bp = &ophelia;// Brass pointer to BrassPlus object
bp->ViewAcct ();// which version?
```
如果在基类中没有将 ViewAcct()声明为虚的，则bp->ViewAcct()将根据指针类型，(Brass*)调用Brass :: ViewAcct()。指针类型在编译时已知，因此编译器在编译时，可以将ViewAcct()关联到Brass :: ViewAcct()。
总之，编译器对非虚方法使用静态联编
然而，如果在基类中将 ViewAcct()声明为虚的，则bp->ViewAcct()根据对象类型(BrassPlus)调用BrassPlus :: ViewAcct()。在这个例子中，对象类型为BrassPlus，但通常只有在运行程序时才能确定对象的类型。所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct()关联到Brass :: ViewAcct()或BrassPlus :: ViewAcct()。
总之，编译器对虚方法使用动态联编

在大多数情况下，动态联编很好，因为它让程序能够选择为特定类型设计的方法。但是会有以下问题：
- 为什么有两种类型的联编?
- 既然动态联编如此之好，为什么不将它设置成默认的?
- 动态联编是如何工作的?

### 1、为什么有两种类型的联编以及为什么默认为静态联编
主要是效率和概念模型
首先来看效率。为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销(稍后将介绍一种动态联编方法)。例如，如果类不会用作基类（不会派生出新类），则不要动态联编；同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。在这些情况下，使用静态联编更合理，效率也更高。由于静态联编的效率更高，因此被设置为C++的默认选择
其次是概念模型
