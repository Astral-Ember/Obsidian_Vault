程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在C++中，由于函数重载的缘故，编译器必须查看函数参数以及函数名才能确定使用哪个函数。C++编译器可以在编译过程中完成这种联编，在编译过程中进行联编被称为静态联编。然而，虚函数使这项工作变得更困难，所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编

## 1.指针和引用类型的兼容性
在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的
通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型:
```
double x = 2.5;
int * pi = &x;// invalid assignment, mismatched pointer types
long & rl = x;// invalid assignment, mismatched reference type
```
指向基类的引用或指针可以引用派生类对象,而不必进行显式类型转换。例如,下面的初始化是允许的:
```
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;// ok
Brass & rb = dilly;// ok
```
将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，BrassPlus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。同时，向上强制转换是可传递的，就是说如果派生类派生出了一个新的派生类，则基类的指针或引用可以引用三类的所有对象
相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类

对于使用基类**引用**或**指针**作为参数的函数调用，将进行向上转换；如果是值传递，只会将派生类对象的基类部分传递给函数
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。

## 2.虚成员函数和动态联编
