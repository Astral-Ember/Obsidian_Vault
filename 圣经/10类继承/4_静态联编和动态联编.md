程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在C++中，由于函数重载的缘故，编译器必须查看函数参数以及函数名才能确定使用哪个函数。C++编译器可以在编译过程中完成这种联编，在编译过程中进行联编被称为静态联编。然而，虚函数使这项工作变得更困难，所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编

## 1.指针和引用类型的兼容性
在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的
通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型:
```
double x = 2.5;
int * pi = &x;// invalid assignment, mismatched pointer types
long & rl = x;// invalid assignment, mismatched reference type
```
指向基类的引用或指针可以引用派生类对象,而不必进行显式类型转换。例如,下面的初始化是允许的:
```
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;// ok
Brass & rb = dilly;// ok
```
将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，BrassPlus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。同时，向上强制转换是可传递的，就是说如果派生类派生出了一个新的派生类，则基类的指针或引用可以引用三类的所有对象
相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类

对于使用基类**引用**或**指针**作为参数的函数调用，将进行向上转换；如果是值传递，只会将派生类对象的基类部分传递给函数
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。

## 2.虚成员函数和动态联编


.来回顾一下使用引用或指针调用方法的过程:
```
BrassPlus ophelia;// derived-class object
Brass * bp;// base-class pointer
bp = &ophelia;// Brass pointer to BrassPlus object
bp->ViewAcct ();// which version?
```
如果在基类中没有将 ViewAcct()声明为虚的，则bp->ViewAcct()将根据指针类型，(Brass*)调用Brass :: ViewAcct()。指针类型在编译时已知，因此编译器在编译时，可以将ViewAcct()关联到Brass :: ViewAcct()。
总之，编译器对非虚方法使用静态联编
然而，如果在基类中将 ViewAcct()声明为虚的，则bp->ViewAcct()根据对象类型(BrassPlus)调用BrassPlus :: ViewAcct()。在这个例子中，对象类型为BrassPlus，但通常只有在运行程序时才能确定对象的类型。所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct()关联到Brass :: ViewAcct()或BrassPlus :: ViewAcct()。
总之，编译器对虚方法使用动态联编

在大多数情况下，动态联编很好，因为它让程序能够选择为特定类型设计的方法。但是会有以下问题：
- 为什么有两种类型的联编?
- 既然动态联编如此之好，为什么不将它设置成默认的?
- 动态联编是如何工作的?

### 1、为什么有两种类型的联编以及为什么默认为静态联编
主要是效率和概念模型
首先来看效率。为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销(稍后将介绍一种动态联编方法)。例如，如果类不会用作基类（不会派生出新类），则不要动态联编；同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。在这些情况下，使用静态联编更合理，效率也更高。由于静态联编的效率更高，因此被设置为C++的默认选择
其次是概念模型，在设计类时，可能会包含一些不需要在派生类重新定义的函数，例如第一节的Name()函数。不将此类函数设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚的
==注意==：如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。

### 2、虚函数的工作原理
编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址
调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。
总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：
- 每个对象都将增大，增大量为存储地址的空间;
- 对于每个类，编译器都创建一个虚函数地址表(数组);
- 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。
虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能


## 3.有关虚函数的注意事项
此前已经讨论了虚函数的一些要点：
- 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类(包括从派生类派生出来的类)中是虚的。
- 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
- 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。

但是还有一些其他知识点
### 1、构造函数
构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义

