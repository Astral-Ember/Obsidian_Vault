程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。在C++中，由于函数重载的缘故，编译器必须查看函数参数以及函数名才能确定使用哪个函数。C++编译器可以在编译过程中完成这种联编，在编译过程中进行联编被称为静态联编。然而，虚函数使这项工作变得更困难，所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编

## 1.指针和引用类型的兼容性
在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的
通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型:
```
double x = 2.5;
int * pi = &x;// invalid assignment, mismatched pointer types
long & rl = x;// invalid assignment, mismatched reference type
```
指向基类的引用或指针可以引用派生类对象,而不必进行显式类型转换。例如,下面的初始化是允许的:
```
BrassPlus dilly ("Annie Dill", 493222, 2000);
Brass * pb = &dilly;// ok
Brass & rb = dilly;// ok
```
将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，BrassPlus对象都是Brass对象，因为它继承了Brass对象所有的数据成员和成员函数。同时，向上强制转换是可传递的，就是说如果派生类派生出了一个新的派生类，则基类的指针或引用可以引用三类的所有对象
相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类 ^ddb479

对于使用基类**引用**或**指针**作为参数的函数调用，将进行向上转换；如果是值传递，只会将派生类对象的基类部分传递给函数
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。 ^d0ae26

## 2.虚成员函数和动态联编

^a50ee5


回顾一下使用引用或指针调用方法的过程:
```
BrassPlus ophelia;// derived-class object
Brass * bp;// base-class pointer
bp = &ophelia;// Brass pointer to BrassPlus object
bp->ViewAcct ();// which version?
```
如果在基类中没有将 ViewAcct()声明为虚的，则bp->ViewAcct()将根据指针类型，(Brass*)调用Brass :: ViewAcct()。指针类型在编译时已知，因此编译器在编译时，可以将ViewAcct()关联到Brass :: ViewAcct()。
总之，编译器对非虚方法使用静态联编
然而，如果在基类中将 ViewAcct()声明为虚的，则bp->ViewAcct()根据对象类型(BrassPlus)调用BrassPlus :: ViewAcct()。在这个例子中，对象类型为BrassPlus，但通常只有在运行程序时才能确定对象的类型。所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct()关联到Brass :: ViewAcct()或BrassPlus :: ViewAcct()。
总之，编译器对虚方法使用动态联编

在大多数情况下，动态联编很好，因为它让程序能够选择为特定类型设计的方法。但是会有以下问题：
- 为什么有两种类型的联编?
- 既然动态联编如此之好，为什么不将它设置成默认的?
- 动态联编是如何工作的?

### 1、为什么有两种类型的联编以及为什么默认为静态联编
主要是效率和概念模型
首先来看效率。为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销(稍后将介绍一种动态联编方法)。例如，如果类不会用作基类（不会派生出新类），则不要动态联编；同样，如果派生类不重新定义基类的任何方法，也不需要动态联编。在这些情况下，使用静态联编更合理，效率也更高。由于静态联编的效率更高，因此被设置为C++的默认选择
其次是概念模型，在设计类时，可能会包含一些不需要在派生类重新定义的函数，例如第一节的Name()函数。不将此类函数设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚的
==注意==：如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。

### 2、虚函数的工作原理
编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址
调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。
总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：
- 每个对象都将增大，增大量为存储地址的空间;
- 对于每个类，编译器都创建一个虚函数地址表(数组);
- 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。
虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能


## 3.有关虚函数的注意事项
此前已经讨论了虚函数的一些要点：
- 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类(包括从派生类派生出来的类)中是虚的。
- **如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象**。
- 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。

但是还有一些其他知识点
### 1、构造函数
构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义

### 2、析构函数

^c07cf7

析构函数应当是虚函数，除非类不用做基类。例如，假设Employee是基类，Singer是派生类，并添加一个char* 成员，该成员指向由new分配的内存。当Singer对象过期时，必须调用~Singer()析构函数来释放内存。
```
Employee * pe = new Singer; // legal because Employee is base for Singer
...
delete pe;// ~Employee() or ~Singer ()?
```
如果使用默认的静态联编，delete语句将调用~Employee()析构函数。这将释放由 Singer 对象中的
Employee部分指向的内存，但不会释放新的类成员指向的内存。但如果析构函数是虚的，则上述代码将先调用~Singer析构函数释放由Singer组件指向的内存，然后，调用~Employee()析构函数来释放由Employee组件指向的内存。
这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作:
`virtual ~BaseClass () { }`

### 3、友元

^575fd7

友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。

### 4、没有重新定义
如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的(稍后将介绍)。

### 5、重新定义将隐藏方法
假设创建了如下所示的代码:
```
class Dwelling
{
public:
virtual void showperks (int a) const;
...
}
class Hovel : public Dwelling
{
public:
virtual void showperks() const;
...
}
```
这将导致问题，代码将有以下含义：
```
Hovel trump;
trump. showperks () ;//valid
trump. showperks (5);// invalid
```
新定义将showperks()定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int 参数的基类版本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。

这引出了两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针(这种例外是新出现的)。这种特性被称为返回类型协变(covariance of return type)，因为允许返回类型随类类型的变化而变化：
```
class Dwelling
{
public:
	// a base method
	virtual Dwelling & build(int n);
..
}
class Hovel : public Dwelling
{
public:
	// a derived method with a covariant return type
	virtual Hovel & build(int n); // same function signature
}
```
==注意==：这种例外只适用于返回值，而不适用于参数。
第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。
```
class Dwelling
{
public:
	// three overloaded showperks ()
	virtual void showperks(int a) const;
	virtual void showperks (double x) const;
	virtual void showperks() const;
	...
}
class Hovel : public Dwelling
{
public:
	// three redefined showperks()
	virtual void showperks (int a) const;
	virtual void showperks (double x) const;
	virtual void showperks () const;
}
```
如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义可只调用基类版本：
`void Hovel::showperks() const {Dwelling::showperks();}`
