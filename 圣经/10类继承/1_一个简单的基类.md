从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
举个例子：
.h
```
#pragma once
#include <string>
using namespace std; 

class TableTennisPlayer
{
public:
	TableTennisPlayer(const string& fn = "none",const string& ln = "none", bool ht = false);
	bool HasTable() const { return hasTable; };
	void ResetTable(bool v) { hasTable = v; };
	void Name() const;
private:
	string firstName;
	string lastName;
	bool hasTable;
};
```

.cpp
```
#include <iostream>
#include "FileName.h"


TableTennisPlayer::TableTennisPlayer(const string& fn, const string& ln, bool ht) :firstName(fn), lastName(ln), hasTable(ht)
{
}

void TableTennisPlayer::Name() const
{
	cout << lastName << "," << firstName;
}

int main()
{
	using std::cout;
	TableTennisPlayer player1("Chuck", "Blizzard", true);
	TableTennisPlayer player2("Tara", "Boomdea", false);
	player1.Name();
	if (player1.HasTable())
		cout << ": has a table.\n";
	else
		cout << ": hasn't a table. \n";
	player2.Name();
	if (player2.HasTable())
		cout << ": has a table";
	else
		cout << ": hasn't a table.\n";
}
```

创建了TableTennisPlayer 类，只是记录会员的姓名以及是否有球桌

## 1.派生一个类
Webtown俱乐部的一些成员曾经参加过当地的乒乓球锦标赛，需要这样一个类，它能包括成员在比赛中的比分。与其从零开始，不如从 TableTennisClass 类派生出一个类。首先将 RatedPlayer 类声明为从TableTennisPlayer类中派生而来
```
// RatedPlayer derives from the TableTennisPlayer base class
class RatedPlayer : public TableTennisPlayer
{
...
}
```
冒号指出 RatedPlayer 类的基类是TableTennisplayer类。上述特殊的声明头（public）表明TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）

此时RatedPlayer对象将具有以下特征：
- 派生类对象存储了基类的数据成员（派生类继承了基类的实现）;
- 派生类对象可以使用基类的方法（派生类继承了基类的接口）
因此，RatedPlayer 对象可以存储运动员的姓名及其是否有球桌。另外，RatedPlayer 对象还可以使用Table TennisPlayer 类的Name()、hasTable()和ResetTable()方法

需要在继承特性中添加什么呢？
- 派生类需要自己的构造函数
- 派生类可以根据需要添加额外的数据成员和成员函数

在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。因此，类声明与下面类似:
```
class RatedPlayer : public TableTennisPlayer
{
public:
	RatedPlayer(unsigned int r = 0, const string& fn = "none", const string& In = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer& tp);
	unsigned int Rating() const { return rating; } // add a method
	void ResetRating(unsigned int r) { rating = r; } // add a method
private:
	unsigned int rating;// add a data member
};
```
构造函数必须给新成员(如果有的话)和继承的成员提供数据。在第一个RatedPlayer构造函数中，每个成员对应一个形参；而第二个 Ratedplayer 构造函数使用一个 TableTennisPlayer 参数，该参数包括firstname、lastname和 hasTable


## 2.构造函数：访问权限的考虑
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，RatedPlayer构造函数不能直接设置继承的成员(firstname、lastname和hasTable)，而必须使用基类的公有方法来访问私有的基类成员。具体地说，**派生类构造函数必须使用基类构造函数**
对于第一个派生类构造函数：
```
RatedPlayer :: RatedPlayer (unsigned int r, const string & fn,const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
	rating = r;
}
```
TableTennisPlayer(fn, ln, ht)是初始化成员列表，调用了TableTennisPlayer构造函数，相当于创建了一个TableTennisPlayer对象，并对其赋值。整个过程就是将参数从派生类构造函数传递给基类构造函数

==注意==：必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数，除非要使用默认构造函数，否则应显式调用正确的基类构造函数

对于第二个派生类构造函数
```
RatedPlayer :: RatedPlayer(unsigned int r, const TableTennisPlayer& tp) : TableTennisPlayer(tp)
{
	rating = r;
}
```
这里tp的类型为TableTennisPlayer&，意味着将调用基类的复制构造函数，但是基类没有定义复制构造函数，此时
