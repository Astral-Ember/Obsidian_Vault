字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。
第一种来自C语言,常被称为C-风格字符串(C-style string)。
另一种基于string类库的方法。

C-风格字符串具有一种特殊的性质:以空字符(null character)结尾,空字符被写作\0,其ASCII码为0,用来标记字符串的结尾。例如,下面两个声明:
```
char dog [8] = { 'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'}; // not a string!
char cat [8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'}; // a string!
```
这两个数组都是char数组,但只有第二个数组是字符串。==空字符对C-风格字符串而言至关重要==

还可以使用双引号括起字符串，这种字符串被称为字符串常量(string constant)或字符串字面值(string literal),如下所示:
```
char bird [11] = "Mr. Cheeps"; // the \0 is understood
char fish[] = "Bubbles"; // let the compiler count
```
用引号括起的字符串隐式地包括结尾的空字符,因此不用显式地包括它

## 1.拼接字符串常量

有时候,字符串很长,无法放到一行中。C++允许拼接字符串字面值,即将两个用引号括起的字符串合并为一个。事实上,任何两个由空白(空格、制表符和换行符)分隔的字符串常量都将自动拼接成一
因此,下面所有的输出语句都是等效的:
```
cout << "I'd give my right arm to be" " a great violinist.\n";
cout << "I'd give my right arm to be a great violinist.\n";
cout << "I'd give my right ar"
"m to be a great violinist.\n";
```
注意,拼接时不会在被连接的字符串之间添加空格,第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符(不考虑\0)后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。

## 2.在数组中使用字符串

要将字符串存储到数组中,最常用的方法有两种——将数组初始化为字符串常量、将键盘或文件输入读入到数组中
```
char array[15] = "abcdefg";
cout << strlen(array) << '\n'; //7
cout << sizeof(array) << '\n'; //15
array[3] = '\0';
cout << array; //abc
```
首先,sizeof运算符指出整个数组的长度:15字节，但strlen()函数返回的是存储在数组中的字符串的长度,而不是数组本身的长度。另外,strlen()只计算可见的字符,而不把空字符计算在内。因此,对于abcdefg，返回的是7，而不是8
另外,该程序将`array[3]`设置为空字符。这使得字符串在第3个字符后即结束，虽然数组中还有其他的字符

## 3.字符串输入

```
#include <iostream>
using namespace std;
int main()
{
	const int ArSize = 20;
	char name[ArSize];
	char dessert[ArSize];
	cout << "Enter your name: \n";
	cin >> name;
	cout << "Enter your favorite dessert:\n";
	cin >> dessert;
	cout << "I have some delicious " << dessert;
	cout << " for you, " << name << ".\n";
	return 0;
}
```
运行情况:
```
Enter your name:
Alistair Dreeb
Enter your favorite dessert:
I have some delicious Dreeb for you, Alistair.
```
我们甚至还没有对“输入甜点的提示”作出反应，程序便把它显示出来了，然后立即显示最后一行cin使用空白(空格、制表符和换行符)来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。
这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索用户喜欢的甜点时，它发现了Dreeb,因此cin读取Dreeb,并将它放到dessert数组中

这就是 ==带空格的字符串输入问题==

## 4.每次读取一行字符串输入

这个就是用来解决带空格的字符串输入问题的
istream 中的类(如cin)提供了一些面向行的类成员函数:getline()和get()。这两个函数都读取一行输入，直到达到换行符，但是，getline()将丢弃换行符,而get()将换行符保留在输入序列中

### 1、面向行的输入：getline()

getline()函数读取整行,它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法,可以使用cin.getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称,第二个参数是要读的字符数。如果这个参数为20,则函数最多读取19个字符,余下的空间用于存储自动在结尾处添加的空字符。getline()成员函数在读取指定数目的字符或遇到换行符时停止读取。
getline()函数每次读取一行。它通过换行符来确定行尾，但不保存换行符。相反，在存储字符串时，它用空字符来替换换行符
```
#include <iostream>
using namespace std;
int main()
{
	const int ArSize = 20;
	char name[ArSize];
	char dessert[ArSize];
	cout << "Enter your name: \n";
	cin.getline(name, ArSize);
	cout << "Enter your favorite dessert:\n";
	cin.getline(dessert, ArSize);
	cout << "I have some delicious " << dessert;
	cout << " for you, " << name << ".\n";
	return 0;
}
```

### 2、面向行的输入：get()

istream 类有另一个名为get()的成员函数，该函数有几种变体。其中一种变体的工作方式与getline()类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符,而是将其留在输入队列中
因此在输入中可能会出现问题：来不及输入第二段字符串，因为第二个cin读取到的会是\n，因此get()会认为已经到达行尾
==解决此类问题（前后输入内容带有换行符）也有方法：使用不带任何参数的cin.get()来处理换行符==
```
#include <iostream>
using namespace std;
int main()
{
	const int ArSize = 20;
	char name[ArSize];
	char dessert[ArSize];
	cout << "Enter your name: \n";
	cin.get(name, ArSize).get();
	cout << "Enter your favorite dessert:\n";
	cin.get(dessert, ArSize).get();
	cout << "I have some delicious " << dessert;
	cout << " for you, " << name << ".\n";
	return 0;
}
```

为什么要使用get()，而不是getline()呢?首先，老式实现没有getline()。其次,get()使输入更仔细。例如，假设用get()将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行,而不是由于数组已填满呢?查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。总之,getline()使用起来简单一些，但get()使得检查错误更简单些。可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。

### 3、空行和其他问题

当getline()或get()读取空行时，将发生什么情况?最初的做法是，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取;但当前的做法是，当get()(不是getline())读取空行后将设置失效位(failbit)。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入:
`cin.clear();`
另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则getline()和get()将把余下的字符留在输入队列中，而getline()还会设置失效位,并关闭后面的输入



## 5.混合输入字符串和数字

```
	int count;
	cin >> count;
```
在cin完之后将回车键生成的换行符留在了输入队列中，如果后面有getline()或者get()，会因为读取到换行符而认为是一个空行，跳过输入过程
因此可以用cin.get()解决：
```
	int count;
	cin >> count;
	cin.get();
```