## 1.类型别名

^5d6afc

C++为类型建立别名的方式有两种。一种是使用预处理器:
`#define BYTE char // preprocessor replaces BYTE with char`
这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名
第二种方法是使用C++的关键字typedef来创建别名。例如，要将byte作为char的别名，可以这样做：
`typedef char byte; // makes byte an alias for char`
下面是通用格式:
`typedef typeName aliasName;`

## 2.指针和const

^182d4c

### 1、让指针指向一个常量对象（指向常量的指针）
这样可以防止使用该指针来修改所指向的值，但是可以改变该指针的地址
首先，声明一个指向常量的指针pt：
```
	int age=39;
	int age2 = 18;
	const int* ptr = &age;
	*ptr = 12; // invalid
	ptr = &age2; //valid
```

通常将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给指向const的指针。因此还有两种可能：将const变量的地址赋给指向const的指针、将const的地址赋给常规指针。这两种操作都可行吗?第一种可行，但第二种不可行：
```
const float g earth = 9.80;
const float * pe = &g_earth;// VALID

const float g_moon = 1.63;
float * pm = &g_moon;// INVALID
```

==注意==：如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const 指针

### 2、指针常量
不能改变指针指向的地址，但是可以改变值（指针指向地址中存储的值）
```
	int age = 12;
	int age2 = 1;
	int* const ptr = &age;
	*ptr = 11; //valid
	ptr = &age2; //invalid
```

通常，将指针作为函数参数来传递时，可以使用指向const的指针来保护数据
`void show array(const double ar[], int n);`
在该声明中使用const意味着show_array()不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const

### 3、在指针中尽可能使用const
将指针参数声明为指向常量数据的指针有两条理由：
- 这样可以避免由于无意间修改数据而导致的编程错误；
- 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。
如果条件允许，则应将指针形参声明为指向const的指针。


## 3.三种函数参数传递方式

^539eea

分为：
- 值传递
- 指针传递
- 引用传递
详细内容：[[2_引用变量#^0bffa9|参数传递方式]]


## 4.[[3_字符函数库 cctype|字符函数库 cctype]]

^725f7b
## 5.成员初始化列表的语法

^5fefde
如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员：
```
Classy :: Classy(int n, int m) :mem1(n), mem2(0), mem3 (n*m + 2)
{
// ...
}
```


