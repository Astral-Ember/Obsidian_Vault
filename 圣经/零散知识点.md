## 1.类型别名
C++为类型建立别名的方式有两种。一种是使用预处理器:
`#define BYTE char // preprocessor replaces BYTE with char`
这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名
第二种方法是使用C++的关键字typedef来创建别名。例如，要将byte作为char的别名，可以这样做：
`typedef char byte; // makes byte an alias for char`
下面是通用格式:
`typedef typeName aliasName;`

## 2.指针和const
### 1、让指针指向一个常量对象（指向常量的指针）
这样可以防止使用该指针来修改所指向的值，但是可以改变该指针的地址
首先，声明一个指向常量的指针pt：
```
	int age=39;
	int age2 = 18;
	const int* ptr = &age;
	*ptr = 12; // invalid
	ptr = &age2; //valid
```

通常将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给指向const的指针。因此还有两种可能：将const变量的地址赋给指向const的指针、将const的地址赋给常规指针。这两种操作都可行吗?第一种可行，但第二种不可行：
```
const float g earth = 9.80;
const float * pe = &g_earth;// VALID

const float g_moon = 1.63;
float * pm = &g_moon;// INVALID
```

==注意==：如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const 指针

### 2、指针常量
不能改变指针指向的地址，但是可以改变值（指针指向地址中存储的值）
```
	int age = 12;
	int age2 = 1;
	int* const ptr = &age;
	*ptr = 11; //valid
	ptr = &age2; //invalid
```

通常，将指针作为函数参数来传递时，可以使用指向const的指针来保护数据
`void show array(const double ar[], int n);`
在该声明中使用const意味着show_array()不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针,则不能使用const
