将一种算术类型的值赋给另一种算术类型的变量时,C++将对值进行转换;
表达式中包含不同的类型时,C++将对值进行转换;
将参数传递给函数时,C++将对值进行转换

## 1. 初始化和赋值进行的转换
   C++允许将一种类型的值赋给另一种类型的变量。这样做时,值将被转换为接收变量的类型
   ==在转换时可能会出现精度丢失的问题==
   
   潜在的数值转换问题
   

| 转换                                    | 潜在的问题                                     |
| ------------------------------------- | ----------------------------------------- |
| 将较大的浮点类型转换为较小的浮点类型,如将 double转换为 float | 精度(有效数位)降低,值可能超出目标类型的取值范围,在这种情况下,结果将是不确定的 |
| 将浮点类型转换为整型                            | 小数部分丢失,原来的值可能超出目标类型的取值范围,在这种情况下,结果将是不确定的  |
| 将较大的整型转换为较小的整型,如将long转换为short         | 原来的值可能超出目标类型的取值范围,通常只复制右边的字节              |

## 2.以{}方式初始化时进行的转换(C++11)

C++11将使用大括号的初始化称为列表初始化(list-initialization),因为这种初始化常用于给复杂的数据类型提供值列表。

列表初始化不允许缩窄(narrowing),即变量的类型可能无法表示赋给它的值。例如,不允许将浮点型转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许,条件是编译器知道目标变量能够正确地存储赋给它的值。例如,可将long变量初始化为int值,因为long总是至少与int一样长;相反方向的转换也可能被允许,只要int变量能够存储赋给它的long常量


## 3.表达式中的转换
当同一个表达式中包含两种不同的数据类型时，C++将执行两种自动转换:首先,一些类型在出现时便会自动转换;其次,有些类型在与其他类型同时出现在表达式中时将被转换。

编译器通过校验表来确定在算数表达式中执行的转换，编译器将依次查阅该列表
1. 如果有一个操作数的类型是long double,则将另一个操作数转换为long double。
2. 否则,如果有一个操作数的类型是double,则将另一个操作数转换为double。
3. 否则,如果有一个操作数的类型是float,则将另一个操作数转换为float。
4. 否则,说明操作数都是整型,因此执行整型提升。
5. 在这种情况下,如果两个操作数都是有符号或无符号的,且其中一个操作数的级别比另一个低,则转换为级别高的类型。
6. 如果一个操作数为有符号的,另一个操作数为无符号的,且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。
7. 否则,如果有符号类型可表示无符号类型的所有可能取值,则将无符号操作数转换为有符号操作数所属的类型。
8. 否则,将两个操作数都转换为有符号类型的无符号版本。

## 4.传递参数时的转换
传递参数时的类型转换通常由C++函数原型控制。然而,也可以取消原型对参数传递的控制,尽管这样做并不明智。在这种情况下,C++将对char和short类型(signed和unsigned)应用整型提升。另外,为保持与传统C语言中大量代码的兼容性,在将参数传递给取消原型对参数传递控制的函数时,C++将float参数提升为double。

## 5.强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。(C++认识到,必须有类型规则,而有时又需要推翻这些规则。)强制类型转换的格式有两种。例如,为将存储在变量thorn中的int值转换为long类型,可以使用下述表达式中的一种:
`(long) thorn`
`long (thorn)`
强制类型转换不会修改 thorn 变量本身,而是创建一个新的、指定类型的值,可以在表达式中使用这个值。

强制类型转换的通用格式如下：
`(typeName) value`
`typeName (value)`

C++还引入了4个强制类型转换运算符,对它们的使用要求更为严格,在这四个运算符中，static_cast<>可用于将值从一种数值类型转换为另一种数值类型
`static_cast<typeName> (value)`
