C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。
例如，一下代码使用新的关键字`namespace`创建了两个名称空间：Jack和Jill
```
namespace Jack {
	double pail;// variable declaration
	void fetch();// function prototype
	int pal;// variable declaration
	struct Well { ... };// structure declaration
}

namespace Jill {
	double bucket (double n) { ... }// function definition
	double fetch;// variable declaration
	int pal;//variable declaration
	struct Hill { ... };//structure declaration
}
```
名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的(除非它引用了常量)

如果要访问名称空间中的名称，使用作用域解析运算符`::`
```
Jack::pail = 12.34;// use a variable
Jill::Hill mole;// create a type Hill structure
Jack::fetch () ;// use a function
```

## 1.using声明和using编译指令
using 声明使特定的标识符可用，using编译指令使整个名称空间可用

using 声明由被限定的名称和它前面的关键字using组成:
`using Jill::fetch;// a using declaration`
声明完成后就可用像使用普通变量一样使用fetch

using编译指令使所有的名称都可用。using编译指令由名称空间名和它前面的关键字 using namespace组成,它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：
`using namespace Jack; // make all the names in Jack available`

## 2.命名空间及其前途
随着程序员逐渐熟悉名称空间，将出现统一的编程理念。下面是当前的一些指导原则：
- 使用在已命名的名称空间中声明的变量,而不是使用外部全局变量。
- 使用在已命名的名称空间中声明的变量,而不是使用静态全局变量。
- 如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中,这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。
- 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
- 不要在头文件中使用using 编译指令。首先，这样做掩盖了要让哪些名称可用;另外,包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include 之后
- 导入名称时，首选使用作用域解析运算符或using声明的方法。
- 对于using声明，首选将其作用域设置为局部而不是全局。
