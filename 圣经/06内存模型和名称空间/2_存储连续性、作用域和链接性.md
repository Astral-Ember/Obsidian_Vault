C++使用4中不同的方案存储数据，这些方案的区别在于数据保存在内存中的时间
- 自动存储持续性:在函数定义中声明的变量(包括函数参数)的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建,在执行完函数或代码块时,它们使用的内存被释放。C++有两种存储持续性为自动的变量
- 静态存储持续性:在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量
- 线程存储持续性(C++11):当前,多核处理器很常见,这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的,则其生命周期与所属的线程一样长。本书不探讨并行编程
- 动态存储持续性:用new运算符分配的内存将一直存在,直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态,有时被称为自由存储(free store)或堆(heap)

## 1.作用域和链接
作用域(scope)描述了名称在文件(翻译单元)的多大范围内可见
链接性(linkage)描述了名称如何在不同单元间共享

C++作用域有很多种
- 作用域为局部的变量只在定义它的代码块中可用
- 作用域为全局（也叫做文件作用域）的变量在定义位置到文件结尾之间可用
- 自动变量的作用域为局部,静态变量的作用域是全局还是局部取决于它是如何被定义的
- 在函数原型作用域中使用的名称只在包含参数列表的括号内可用（这就是为什么这些名称是什么以及是否出现都不重要的原因）
- 在类中声明的成员的作用域为整个类
- 在名称空间中声明的变量的作用域为整个命名空间

不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。下面来看看各种C++存储方式的这些特征。首先介绍引入名称空间之前的情况，然后看一看名称空间带来的影响。


## 2.自动存储连续性
在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性
也就是说，如果在main()中声明了一个名为texas的变量，并在函数oil()中也声明了一个名为texas变量，则创建了两个独立的变量——只有在定义它们的函数中才能使用它们。对oil()中的texas执行的任何操作都不会影响main()中的texas，反之亦然


## 3.静态持续变量
C++为静态存储持续性变量提供了3种链接性：
- 外部链接性（可在其他文件中访问）
- 内部链接性（只能在当前文件中访问）
- 无链接性（只能在当前函数或代码块中访问）
这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0

创建外部链接性静态变量，必须在代码块之外声明它；
创建内部链接性静态变量，必须在代码块之外声明它，并使用static关键字
创建无链接性静态变量，必须在代码块内声明它，并使用static关键字

所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0。这种变量
被称为零初始化的（zero-initialized）


## 4.静态持续性、外部链接性
链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的,因此对所有函数而言都是外部的。例如，可以在main()前面或头文件中定义它们。可以在文件中位于外部变量定义后面的任何函数中使用它，因此外部变量也称全局变量（相对于局部的自动变量）
