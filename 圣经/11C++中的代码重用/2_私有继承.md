C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
下面更深入地探讨接口问题。使用公有继承，基类的公有方法将成为派生类的公有方法。总之，派生类将继承基类的接口；这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。总之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。
使用私有继承，类将继承实现。例如，如果从String类派生出Student类，后者将有一个String类组件，可用于保存字符串。另外，Student方法可以使用String方法来访问String组件。
包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语**子对象（subobject）** 来表示通过继承或包含添加的对象。

因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。接下来介绍如何使用私有继承来重新设计Student类。

## 1.Student类示例
要进行私有继承，应使用关键字**private**而不是public来定义类（实际上，private是默认值，因此省略访问限定符也将导致私有继承）。Student类应从两个类派生而来，因此声明将列出这两个类：
```
class Student : private std :: string, private std :: valarray<double>
{
public:
	...
}

```
使用多个基类的继承被称为**多重继承**

### 1、初始化基类组件
隐式地继承组件而不是成员对象将影响代码的编写，因为再也不能使用name和scores来描述对象了，而必须使用用于公有继承的技术。例如，对于构造函数，包含将使这样的构造函数：
```
Student (const char * str, const double * pd, int n)
: name (str), scores (pd, n) {}
```
对于继承类，新版本的构造函数将使用成员初始化列表语，它使用类名而不是成员名来标识构造函数：
```
Student (const char * str, const double * pd, int n)
: std :: string(str), ArrayDb(pd, n) {} // use class names for inheritance
```
在这里,ArrayDb是`std :: valarray<double>`的别名。成员初始化列表使用`std :: string(str)`,而不是name(str)。
这是包含和私有继承之间的第二个主要区别。
唯一不同的地方是，省略了显式对象名称，并在内联构造函数中使用了类名，而不是成员名
