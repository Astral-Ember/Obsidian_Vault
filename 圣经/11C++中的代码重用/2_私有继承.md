C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
下面更深入地探讨接口问题。使用公有继承，基类的公有方法将成为派生类的公有方法。总之，派生类将继承基类的接口；这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。总之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。
使用私有继承，类将继承实现。例如，如果从String类派生出Student类，后者将有一个String类组件，可用于保存字符串。另外，Student方法可以使用String方法来访问String组件。
包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语**子对象（subobject）** 来表示通过继承或包含添加的对象。

因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。接下来介绍如何使用私有继承来重新设计Student类。

## 1.Student类示例
要进行私有继承，应使用关键字**private**而不是public来定义类（实际上，private是默认值，因此省略访问限定符也将导致私有继承）。Student类应从两个类派生而来，因此声明将列出这两个类：
```
class Student : private std :: string, private std :: valarray<double>
{
public:
	...
}

```
使用多个基类的继承被称为**多重继承**

### 1、初始化基类组件
隐式地继承组件而不是成员对象将影响代码的编写，因为再也不能使用name和scores来描述对象了，而必须使用用于公有继承的技术。例如，对于构造函数，包含将使这样的构造函数：
```
Student (const char * str, const double * pd, int n)
: name (str), scores (pd, n) {}
```
对于继承类，新版本的构造函数将使用成员初始化列表语，它使用类名而不是成员名来标识构造函数：
```
Student (const char * str, const double * pd, int n)
: std :: string(str), ArrayDb(pd, n) {} // use class names for inheritance
```
在这里,ArrayDb是`std :: valarray<double>`的别名。成员初始化列表使用`std :: string(str)`,而不是name(str)。
这是包含和私有继承之间的第二个主要区别。
唯一不同的地方是，省略了显式对象名称，并在内联构造函数中使用了类名，而不是成员名

### 2、访问基类的方法
使用私有继承时，只能在派生类的方法中使用基类的方法。但有时候可能希望基类工具是公有的。例如，在类声明中提出可以使用average()函数。和包含一样，要实现这样的目的，可以在公有Student :: average()函数中使用私有Student :: Average()函数。包含使用对象来调用方法：
```
double Student: :Average () const
{
	if (scores.size() > 0)
	return scores.sum()/scores.size();
	else
	return 0;
```
然而，私有继承使得能够使用类名和作用域解析运算符来调用基类的方法：
```
double Student: :Average () const
{
	if (ArrayDb :: size() > 0)
		return ArrayDb :: sum () /ArrayDb:: size () ;
	else
		return 0;
}
```
==总之==，使用包含时将使用对象名来调用方法，而使用私有继承时将使用类名和作用域解析运算符来调用方法。

### 3、访问基类对象
使用作用域解析运算符可以访问基类的方法，但如果要使用基类对象本身，该如何做呢？例如，Student类的包含版本实现了Name()方法，它返回string对象成员name；但使用私有继承时，该string对象没有名称。那么,Student类的代码如何访问内部的string对象呢?

答案是使用[[4_类的自动转换和强制类型转换|强制类型转换]]：由于Student类是从string类派生而来的，因此可以通过强制类型转换，将Student对象转换为string对象；结果为继承而来的string对象。本书前面介绍过，指针this指向用来调用方法的对象，因此* this为用来调用方法的对象，在这个例子中，为类型为Student的对象。为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用：
```
const string & Student :: Name () const
{
	return (const string &) *this;
}
```
上述方法返回一个引用，该引用指向用于调用该方法的Student对象中的继承而来的string对象

## 2.使用包含还是私有继承
由于既可以使用包含，也可以使用私有继承来建立has-a关系，那么应使用种方式呢？大多数C++程序员倾向于使用包含。首先，它易于理解。类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将使关系更抽象。其次，继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或共享祖先的独立基类。总之，使用包含不太可能遇到这样的麻烦。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象（当对象都没有名称时，将难以区分）

然而，私有继承所提供的特性确实比包含多。例如，假设类包含保护成员(可以是数据成员，也可以是成员函数)，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它能够访问保护成员。

另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的

==提示==：通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义
虚函数，则应使用私有继承。


